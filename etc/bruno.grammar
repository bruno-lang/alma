% Fragments
Dashed         : { '-' z 9 }* { z 9 }?
Verb           : z -Dashed?
Noun           : Z { @ '-' } { @  9 }*

% Identifiers
Field          : { z 9 } -Dashed?
Constant       : ':' -Field
Variable       : -Field '''*

Operation      : -Verb '?'?
Function       : -Verb {'?' '*'}?
Module         : -Verb
Library        : -Verb
Namespace      : -Verb
Fault          : -Verb '!'

TypeVariable   : Z 9?
Protocol       : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun

% Operators
Operator       : (-OperatorSymbol)x1-3
OperatorSymbol : { '.' '+' '-' '/' '*' '=' '>' '<' '&' '|' '^' '#' }

% Symbols
Measure        : { @ UnitSymbol }+
UnitSymbol     : { ''' '%' '$' '€' '@' '/' '°' '"' }

% Literals
literal        : LiteralLogic | LiteralText | LiteralBinary
LiteralLogic   : ''' (9+ Measure? | {@ 9}+ UnitSymbol)
LiteralText    : '"' !'"'* '"'
LiteralBinary  : '#' ('b' 1+ | 'o' 7+ | 'd' 9+ | 'x' #+ )

%TODO naming: terminal vs non-terminal
Range          : RangeLiteral | RangeConstant
RangeLiteral   : literal [ >> '..' >> literal ] | '..' >> literal
RangeSet       : '{' >> literal >> (',' >> literal >> )* '}'
RangeConstant  : Constant [ >> '..' >> Constant ] | '..' >> Constant

% Types
TypeVariant    : { '!' '?' '~' '*' }
TypeDimension  : '[' 9* ']'
type           : -base-type TypeDimension? TypeVariant? | op-type
base-type      : Type | list-type | set-type | tuple-type | fn-type | TypeVariable
array-type     : base-type TypeDimension
list-type      : '[' base-type? ']'
set-type       : '{' base-type? '}'
tuple-type     : '(' [ type ( ',' >> type )* ] ')'
fn-type        : '(' type >> '->' ( >> type >> '->' )* >> type ')'
op-type        : Operation fn-type

% Type Variables / Kinds
KindDimension  : '[' (9*):min [ '-' (9*):max ] ']'
instances      : 'instances', TypeVariable, '::', Operation*, kind
kind           : base-kind KindDimension? TypeVariant? | op-kind
base-kind      : '_' | Type | list-kind | set-kind | tuple-kind | fn-kind | TypeVariable
array-kind     : base-kind KindDimension
list-kind      : '[' base-kind? ']'
set-kind       : '{' base-kind? '}'
tuple-kind1    : '..' | kind
tuple-kind     : '(,)' | '(' [ -tuple-kind1 ( ',' >> -tuple-kind1 )* ]  ')'
fn-kind        : '(->)' | '(' kind >> '->' ( >> kind >> '->' )*  >> kind ')'
op-kind        : ( '_' | Operation ) fn-kind

% Modularisation
file           : (library | namespace | module) ,
library        : 'library', Library, '::', '{', Module, (',', Module,)* '}'

namespace      : 'namespace', Namespace, '::', import*, auto*, invariant*
import         : '-use' ~ ['shared' ~] ['strict' ~] Library >> include?,  alias?
include        : ':' >> Module (>> Module)* >> \n
alias          : 'where', ( Type >> '=' >> Type, | Operation >> '=' >> Operation, )+

auto           : '-auto' ^ specialisation
specialisation : bind | refinement
refinement     : type >> '=<>' >> Type .
bind           : Function >> '=<>' >> Operation (>> type)* .

invariant      : '-invariant' ^ Type >> '!' >> Function .

% Implementation
module         : 'module', Module, '::', auto*, invariant*, member+
member         : (val | instances | fn | op | protocol | fault | notation | data | unit | dimension | system),

val            : 'val' >> Constant >> '::' >> type >> expr

data           : 'data' ^ Data >> '::', '(', element, (',', element,)* ')' , format*, enumeration?
element        : type >> Field

format         : '<->', ( tuple-type | array-type | Data ),

enumeration    : '=', ( item-set | item-list | item-range )
item-set       : '{', item, (',', item,)* '}'
item-list      : '[', item, (',', item,)* ']'
item-range     : Constant >> '..' >> Constant
item           : Constant >> expr?
%TODO maybe just use expr here?

dimension      : 'dimension' >> simple, enumeration?

unit           : 'unit' >> simple

simple         : Type >> ['[' Measure ']'] >> '::', Type? >> Range?, format*

system         : 'unit' ^ 'system' ^ System >> '::', '=', (ratio,)*
ratio          : 'ratio' ^ Ratio >> '::', '[', equation, (',', equation,)* ']' .
equation       : literal >> '=' >> literal

fault          : 'fault' >> Fault >> '::', Type, Range?

notation       : 'notation' >> Notation >> '::', type?, [ '=', '{', type, (',', type,) '}' ]

protocol       : 'protocol' >> Protocol >> '::', '{', Operation, (',', Operation,) '}'

op             : 'op' >> Operation >> ['[' Operator ']'] >> '::', Operation?, signature

fn             : 'fn' >> Function >> ['[' Operator ']'] >> '::', signature, implementation, [ where ]
signature      : -descriptor | '(' >> -descriptor >> ')'
descriptor     : ( parameter >> '->' >> )+ type
parameter      : type ^ Variable:name
implementation : ['\' >> expr >> '?' .] ('\' >> -expressions >> '\', '=' >> expr . )* [['\' >> '\'] '=' >> expr . ]
where          : 'where', declaration >> (declaration >> )*
declaration    : variable | deduction
variable       : type ^ Variable >> '=' >> expr .

% Expressions
expr           : expr1 ( >> expr1 )*
expr1          : tuple | list | set | atom
list           : '[]' | '[', -expressions, ']'
set            : '{}' | '{', -expressions, '}'
tuple          : '()' | '(', -expressions, ')'
expressions    : expr (, ',', expr )*
atom           : Range | literal | Constant | Operator | Variable | Type | Fault