% Fragments
Dashed         : { '-' z 9 }* { z 9 }?
Verb           : z -Dashed?
Noun           : Z { @ '-' } { @  9 }*
number         : ({'+' '-'}?):sign ({9 '.' ',' '_'}+):number

% Identifiers
Wildcard       : '_'
Artifact       : '.' z {z 9 '-'}*
Field          : { z 9 } -Dashed?
Constant       : -Noun
Variable       : -Field '''*
Atom           : '`'{ !_ }+
Alias          : '?'{ @ 9 '-' '_' }+

Operation      : -Verb '?'?
Function       : -Verb {'?' '*'}?
Fault          : -Verb '!'

Module         : -Artifact
Library        : -Artifact
Namespace      : -Artifact

TypeVariable   : Z 9?
Protocol       : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun

% Operators
Operator       : (-OperatorLetter)x1-3
OperatorLetter : { '+' '-' '/' '*' '=' '>' '<' '&' '|' '#' '~' }

% Symbols
Symbol         : { @ UnitLetter }+
UnitLetter     : { ''' '$' '€' '/' '°' '"' }

% Literals
literal        : logic-literal | text-literal | bit-literal
logic-literal  : ''' ( (-number['e'number:exponent] Symbol?) | ($ .. UnitLetter):value )
text-literal   : '"""', (..):text (, '"""') | '"' (!'"'*):text '"'
bit-literal    : '#' ('b' 1+ | 'o' 7+ | 'd' 9+ | 'x' #+ ):number

values         : literal-set | literal-range | constant-range
literal-set    : '{' >> literal >> (',' >> literal >> )* '}'
literal-range  : literal [ >> '..' >> literal ] | '..' >> literal
constant-range : Constant [ >> '..' >> Constant ] | '..' >> Constant

% Types
% TODO capture struct layout in memory in type (reference vs. embedded) - use ':' in front of whole tuple to say everything should be embedded, references are than modeled as "pointer" types (use '@') 
modifier       : { '!' '?' '*' }
class          : {'$' '^'}
dimension-type : '[' ( TypeVariable | (9*):min ['-'(9*):max] ) ']' | '..'
type           : class? -base-type dimension-type* modifier? | op-type
base-type      : Type | list-type | set-type | tuple-type | fn-type | TypeVariable
array-type     : -base-type dimension-type+
list-type      : '[' base-type? ']'
set-type       : '{' base-type? '}'
tuple-type     : ':'? '(' [ type ( ',' >> type )* ] ')'
fn-type        : '(' type >> '->' ( >> type >> '->' )* >> type ')'
op-type        : Operation fn-type

% Type Variables / Kinds
instances      : 'instances', TypeVariable, '::', kind [, '&' >> Operation+]
kind           : class? -base-kind dimension-type* modifier? | op-kind
base-kind      : Wildcard | Type | dimension-kind | list-kind | set-kind | tuple-kind | fn-kind | TypeVariable
dimension-kind : (9+):min [ '-' (9*):max ]
array-kind     : -base-kind dimension-type+
list-kind      : '[' base-kind? ']'
set-kind       : '{' base-kind? '}'
tuple-kind1    : '..' | kind
tuple-kind     : ':'? ('(,)' | '(' [ -tuple-kind1 ( ',' >> -tuple-kind1 )* ]  ')')
fn-kind        : '(->)' | '(' kind >> '->' ( >> kind >> '->' )*  >> kind ')'
op-kind        : ( Wildcard | Operation ) fn-kind

% Modularisation
file           : module | namespace
namespace      : form

% Implementation
module         : (, declaration)+ .
declaration    : val | instances | fn | op | protocol | fault | notation | data | system | unit | dimension

fault          : 'fault' >> Fault >> '::', < Type, values?

system         : 'unit' ^ 'system' ^ System >> '::', < '=', (ratio,)*
ratio          : 'ratio' ^ Ratio >> '::', < '[', equation, (',', equation,)* ']' .
equation       : literal >> '=' >> literal

% Values
val            : 'val' >> Constant >> '::' < >> [type >>] '=' >> expr

data           : 'data' ^ Data >> '::', < (record | type), format*, enumeration?
record         : ':'? '('<, field, (',', field,)* ')'
field          : type ^ Field
format         : '<~>', ( tuple-type | array-type | Data ),
enumeration    : '=', form

dimension      : 'dimension' >> -primitive, enumeration?
unit           : 'unit' >> -primitive
primitive      : Type < >> ['[' Symbol ']'] >> '::', ((Atom ^)*):aspect  [Type >> values?], format*

% Somewhat abstract data types
notation       : 'notation' >> Notation >> '::', < type?, [ '=', '{', type, (',', type,) '}' ]

protocol       : 'protocol' >> Protocol >> '::', < '{', Operation, (',', Operation,)* '}'

% Functions
op             : 'op' >> Operation >> < ['[' Operator ']'] >> '::', Operation?, signature

fn             : 'fn' >> Function >> < ['[' Operator ']'] >> '::', signature, ( '=', ':native' | implementation, [ where ]) 
signature      : -descriptor | '(' >> -descriptor >> ')'
descriptor     : ( parameter >> '->' >> )+ type
parameter      : type ^ -Variable:name
implementation : ['\' >> expr >> ':' .] ('\' >> -expressions >> '\', '=' >> expr . )* [['\' >> '\'] '=' >> expr . ]
where          : 'where', clause >> (clause >> )*
clause         : variable | specialisation
variable       : type ^ Variable >> '=' >> expr .
specialisation : bind | promotion
promotion      : type >> '~>' >> Type .
bind           : Function >> '~>' >> Operation (>> type)* .

% Expressions
expr           : form ( >> form )*
form           : tuple | list | set | comment | element
list           : '[]' | '[', -expressions, ']'
set            : '{}' | '{', -expressions, '}'
tuple          : '()' | '(', -expressions, ')'
comment        : '%' .. '%'
expressions    : expr (, ','?, expr )*
element        : Wildcard | Atom | values | literal | Artifact | Constant | Operator | Variable | Type | Fault | Alias