% Fragments
Verb           : z { z 9 '-' }* { z 9 }?
Noun           : Z { @ '-' }+ { @  9 }*
Identifier     : -Verb {'?' '!'}?

% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '~'
SliceOf        : ':'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Specialisation : '~>'

% Identifiers
Wildcard       : '_'
Artifact       : '.' z {z 9 '-'}*
Field          : -Verb
Constant       : -Noun
Atom           : '`'{ !_ }+
Key            : -KeyOf{ !_ !',' }+
Variable       : '?'{ @ 9 '-' '_' }+

Operation      : -Identifier
Function       : -Identifier

Module         : -Artifact
Library        : -Artifact
Namespace      : -Artifact

TypeVariable   : Z 9?
Behaviour      : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun
Process        : -Noun
Fault          : -Noun '!'

% Operators
Operator       : { '+' '-' '/' '*' '=' '>' '<' '&' '|' }x1-3

% Unit Symbols
UnitSymbol     : { @ -UnitLetter }+
UnitLetter     : { ''' '$' '€' '/' '°' '"' }

% Literals
literal        : conceptual | textual | binary
conceptual     : ''' ( (number['e'number:EXPONENT] UnitSymbol?) | ($ .. UnitLetter):VALUE )
textual        : '"""', (..):TEXT (, '"""') | '"' (!'"'*):TEXT '"'
binary         : '#'< ('b'< 1+ | 'o'< 7+ | 'x'< #+ | 'd'? 9+ ):NUMBER nb?
number         : ({'+' '-'}?):SIGN ({9 '.' ',' '_'}+):NUMBER nb?
% nota bene (call site literal comments)
nb             : '\' @+ 

values         : literal-set | literal-range | constant-range
literal-set    : '{' >> literal >> (',' >> literal >> )* '}'
literal-range  : literal [ >> '..' >> literal ] | '..' >> literal
constant-range : Constant [ >> '..' >> Constant ] | '..' >> Constant

% Types
modifier       : { Faulty Optional Transient }
class          : { TypeOf LazyOf KeyOf }
length-type    : 9+ | '*' | Type | TypeVariable
range-type     : length-type:MIN '-' length-type:MAX
dimension-type : '[' SliceOf? (range-type|length-type)? ']' | '..'
channel-type   : {'[' ']'} {'<' '>'}x1-2 < {'[' ']'}
stream-type    : {'<' '>'}
variant        : stream-type? dimension-type* [channel-type* dimension-type?] modifier?
type           : class? -base-type variant? | op-type
base-type      : Type | list-type | set-type | tuple-type | fn-type | TypeVariable
list-type      : '['< -type? ']'
set-type       : '{'< -type? '}'
tuple-type     : '(' [ type ( ',' >> type )* ] ')'
fn-type        : '(' type:INSTANCE >> '->' ( >> type >> '->' )* >> type:RETURN ')'
op-type        : Operation fn-type

% Type Variables / Kinds
instances      : 'instances', < TypeVariable, '::', kind [, '&' >> Operation+]
kind           : op-kind | class? -base-kind variant?
base-kind      : Wildcard | Type | range-type | length-type | list-kind | set-kind | tuple-kind | fn-kind | TypeVariable
list-kind      : '[' -kind? ']'
set-kind       : '{' -kind? '}'
elem-kind      : '..' | kind
tuple-kind     : '(,)' | '(' [ -elem-kind ( ',' >> -elem-kind )* ]  ')'
fn-kind        : '(->)' | '(' kind:INSTANCE >> '->' ( >> kind >> '->' )*  >> kind:RETURN ')'
op-kind        : ( Wildcard | Operation ) fn-kind

% Modularisation
file           : module | namespace
namespace      : form

% Implementation
module         : (, -declaration)+ .
declaration    : val | key | instances | process | fn | op | behaviour | fault | notation | data | system | unit | dimension | when | comment

fault          : 'fault' >> Fault >> '::', < Type, values?

system         : 'unit' ^ 'system' < ^ System >> '::', '=', (ratio,)*
ratio          : 'ratio' < ^ Ratio >> '::', '[', equation, (',', equation,)* ']' .
equation       : literal >> '=' >> literal

% Values
val            : 'val' < ^ Constant >> '::' >> [type >>] '=' >> expr .
key            : 'key' < ^ Key >> '::' >> type .

data           : 'data' < ^ Data >> '::', (record | type), format*, enumeration?
record         : '('<, field, (',', field,)* ')'
field          : type ^ Field
format         : ':'<, ('#'< -pattern '[]'? | '"' -pattern '"' ),
pattern        : '(' ( (type | literal)+','?,)+ ')'
enumeration    : '=', form

dimension      : 'dimension' < ^ -primitive, enumeration?
unit           : 'unit' < ^ -primitive
primitive      : Type < >> ['[' UnitSymbol ']'] >> '::', ((Atom ^)*):aspects  [Type >> values? >> (',' >> Constant >>)*], format*

% Somewhat abstract data types
notation       : 'notation' < ^ Notation >> '::', type?, [ '=', '{', type, (',', type,) '}' ]:members

behaviour      : 'behaviour' < ^ Behaviour >> '::', [Behaviour, (',', Behaviour,)] ['=', '{', Operation, (',', Operation,)* '}']

% Functions
op             : 'op' < ^ Operation >> ['[' Operator ']'] >> '::', Operation?, signature

fn             : ('fn'|'proc') < ^ Function >> ['[' Operator ']'] >> '::', signature?, implementation, [ where ] 
signature      : -descriptor | '('< >> -descriptor >> ')'
descriptor     : ( parameter >> '->' >> )+ type
parameter      : type ^ -Identifier:NAME
implementation : ('\' >> -vector >> '\', -assign )* [['\' >> '\'], -assign ]
where          : 'where' < , -clause >> (-clause >> )*
clause         : variable | bind | specialisation | switch
switch         : '\' >> -vector >> '\'.
variable       : type ^ Identifier >> -assign
assign         : direct | select
direct         : '=' >> expr .
select         : (, '|=' >> expr . )+ [, 'L=' >> expr .] 
specialisation : type >> -Specialisation >> Type .
bind           : Function >> -Specialisation >> Operation (>> type)* .

% Expressions
vector         : expr (, {',' ';'}?, expr )*
expr           : form ( >> form )*
form           : eval | tuple | list | set | comment | term
eval           : '(:=', -vector, ')'
inline         : '~' Function
tuple          : '()' | '(', -vector, ')'
list           : '[]' | '[', -vector, ']'
set            : '{}' | '{', -vector, '}'
comment        : '%' .. '%'
term           : Wildcard | Atom | Key | values | literal | Artifact | Constant 
               | Operator | Identifier | inline | Type | Fault | Variable | TypeVariable

% Processes
process        : 'process' < ^ Process >> '::', (list | set)
when           : 'when' < ^ state >> '::', signature, effects, -transitions, where?
state          : Fault | ('_!'):any-fault | Constant
effects        : (effect .)*
effect         : 9'.' < ^ expr
transitions    : '..', ( (transition .)* | .)
transition     : ['\'< >> -vector >> '\',] >> Constant >> ':', expr