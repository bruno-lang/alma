% Fragments
Dashed         : { '-' z 9 }* { z 9 }?
Verb           : z -Dashed?
Noun           : Z { @ '-' } { @  9 }*

% Identifiers
Field          : { z 9 } -Dashed?
Constant       : ':' -Field
Variable       : -Field '''*

Operation      : -Verb '?'?
Function       : -Verb {'?' '*'}?
Module         : -Verb
Library        : -Verb
Namespace      : -Verb
Fault          : -Verb '!'

TypeVariable   : Z 9?
Protocol       : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun

% Operators
Operator       : (-OperatorSymbol)x1-3
OperatorSymbol : { '.' '+' '-' '/' '*' '=' '>' '<' '&' '|' '^' '#' ':' '@' }

% Symbols
Measure        : { @ UnitSymbol }+
UnitSymbol     : { ''' '%' '$' '€' '/' '°' '"' }

% Literals
literal        : LogicLiteral | TextLiteral | BinaryLiteral
LogicLiteral   : ''' ( (9+ Measure?):number | ($ .. UnitSymbol):value )
TextLiteral    : '"' (!'"'*):text '"'
BinaryLiteral  : '#' ('b' 1+ | 'o' 7+ | 'd' 9+ | 'x' #+ ):number

range          : literal-set | literal-range | constant-range
literal-range  : literal [ >> '..' >> literal ] | '..' >> literal
constant-range : Constant [ >> '..' >> Constant ] | '..' >> Constant
literal-set    : '{' >> literal >> (',' >> literal >> )* '}'

% Types
TypeVariant    : { '!' '?' '~' '*' }
TypeDimension  : '[' 9* ['-'9+] ']' | '..'
type           : -base-type TypeDimension? TypeVariant? | op-type
base-type      : Type | list-type | set-type | tuple-type | fn-type | TypeVariable
array-type     : -base-type TypeDimension
list-type      : '[' base-type? ']'
set-type       : '{' base-type? '}'
tuple-type     : '(' [ type ( ',' >> type )* ] ')'
fn-type        : '(' type >> '->' ( >> type >> '->' )* >> type ')'
op-type        : Operation fn-type

% Type Variables / Kinds
KindDimension  : '[' (9*):min [ '-' (9*):max ] ']' | '..'
instances      : 'instances', TypeVariable, '::', kind, ['&' >> Operation+]
kind           : -base-kind KindDimension? TypeVariant? | op-kind
base-kind      : '_' | Type | list-kind | set-kind | tuple-kind | fn-kind | TypeVariable
array-kind     : -base-kind KindDimension
list-kind      : '[' base-kind? ']'
set-kind       : '{' base-kind? '}'
tuple-kind1    : '..' | kind
tuple-kind     : '(,)' | '(' [ -tuple-kind1 ( ',' >> -tuple-kind1 )* ]  ')'
fn-kind        : '(->)' | '(' kind >> '->' ( >> kind >> '->' )*  >> kind ')'
op-kind        : ( '_' | Operation ) fn-kind

% Modularisation
file           : (library | namespace | module) ,
library        : 'library', Library, '::', '{', Module, (',', Module,)* '}'

namespace      : 'namespace', Namespace, '::', import*, auto*, invariant*
import         : '-use' ~ ['shared' ~] ['strict' ~] Library >> include?,  alias?
include        : ':' >> Module (>> Module)* >> \n
alias          : 'where', ( Type >> '=' >> Type, | Operation >> '=' >> Operation, )+

auto           : '-auto' ^ specialisation
specialisation : bind | refinement
refinement     : type >> '=<>' >> Type .
bind           : Function >> '=<>' >> Operation (>> type)* .

invariant      : '-invariant' ^ Type >> '!' >> Function .

% Implementation
module         : 'module', Module, '::', auto*, invariant*, member+
member         : (val | instances | fn | op | protocol | fault | notation | data | system | unit | dimension ),

% Values
val            : 'val' >> Constant >> '::' < >> type >> '='? >> expr

data           : 'data' ^ Data >> '::', < (struct | type)
struct         : '(', element, (',', element,)* ')' , format*, enumeration?
element        : type >> Field
format         : '<->', ( tuple-type | array-type | Data ),
enumeration    : '=', expr1

dimension      : 'dimension' >> < -primitive, enumeration?
unit           : 'unit' >> -primitive
primitive      : Type >> ['[' Measure ']'] >> '::', ['relative'|'absolute']:aspect >> [Type >> range?], format*

system         : 'unit' ^ 'system' ^ System >> '::', < '=', (ratio,)*
ratio          : 'ratio' ^ Ratio >> '::', < '[', equation, (',', equation,)* ']' .
equation       : literal >> '=' >> literal

fault          : 'fault' >> Fault >> '::', < Type, range?

notation       : 'notation' >> Notation >> '::', < type?, [ '=', '{', type, (',', type,) '}' ]

protocol       : 'protocol' >> Protocol >> '::', < '{', Operation, (',', Operation,)* '}'

op             : 'op' >> Operation >> < ['[' Operator ']'] >> '::', Operation?, signature

fn             : 'fn' >> Function >> < ['[' Operator ']'] >> '::', signature, ( '=', '&native' | implementation, [ where ]) 
signature      : -descriptor | '(' >> -descriptor >> ')'
descriptor     : ( parameter >> '->' >> )+ type
parameter      : type ^ -Variable:name
implementation : ['\' >> expr >> '?' .] ('\' >> -expressions >> '\', '=' >> expr . )* [['\' >> '\'] '=' >> expr . ]
where          : 'where', declaration >> (declaration >> )*
declaration    : variable | specialisation
variable       : type ^ Variable >> '=' >> expr .

% Expressions
expr           : expr1 ( >> expr1 )*
expr1          : tuple | list | set | atom
list           : '[]' | '[', -expressions, ']'
set            : '{}' | '{', -expressions, '}'
tuple          : '()' | '(', -expressions, ')'
expressions    : expr (, ',', expr )*
atom           : range | literal | Constant | Operator | Variable | Type | Fault