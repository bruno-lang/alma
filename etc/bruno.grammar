% Fragments
Dashed         : { z 9 '-' }* { z 9 }?
Verb           : z -Dashed?
Noun           : Z { @ '-' } { @  9 }*
Identifier     : -Verb {'?' '~' }?

% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '^'
SliceOf        : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'

% Identifiers
Wildcard       : '_'
Artifact       : '.' z {z 9 '-'}*
Field          : -Verb
Constant       : -Noun
Atom           : '`'{ !_ }+
Variable       : '?'{ @ 9 '-' '_' }+

Operation      : -Verb
Function       : Identifier
Fault          : -Verb '!'

Module         : -Artifact
Library        : -Artifact
Namespace      : -Artifact

TypeVariable   : Z 9?
Behaviour      : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun

% Operators
Operator       : { '+' '-' '/' '*' '=' '>' '<' '&' '|' }x1-3

% Symbols
Symbol         : { @ UnitLetter }+
UnitLetter     : { ''' '$' '€' '/' '°' '"' }

% Literals
literal        : conceptual | textual | binary
conceptual     : ''' ( (-number['e'number:exponent] Symbol?) | ($ .. UnitLetter):value )
textual        : '"""', (..):text (, '"""') | '"' (!'"'*):text '"'
binary         : '#'< ('b'< 1+ | 'o'< 7+ | 'x'< #+ | 'd'? 9+ ):number nb?
number         : ({'+' '-'}?):sign ({9 '.' ',' '_'}+):number nb?
% nota bene (call site literal comments)
nb             : '\' @+ 

values         : literal-set | literal-range | constant-range
literal-set    : '{' >> literal >> (',' >> literal >> )* '}'
literal-range  : literal [ >> '..' >> literal ] | '..' >> literal
constant-range : Constant [ >> '..' >> Constant ] | '..' >> Constant

% Types
modifier       : { Faulty Optional Transient }
class          : { TypeOf LazyOf SliceOf }
length-type    : 9+ | '*' | Type | TypeVariable
range-type     : length-type:min '-' length-type:max
dimension-type : '['< (range-type|length-type)? ']' | '..'
type           : class? -base-type dimension-type* modifier? | op-type
base-type      : Type | list-type | set-type | tuple-type | fn-type | TypeVariable
array-type     : -base-type dimension-type+
list-type      : '['< base-type? ']'
set-type       : '{'< base-type? '}'
tuple-type     : '(' [ type ( ',' >> type )* ] ')'
fn-type        : '(' type >> '->' ( >> type >> '->' )* >> type ')'
op-type        : Operation fn-type

% Type Variables / Kinds
instances      : 'instances', < TypeVariable, '::', kind [, '&' >> Operation+]
kind           : op-kind | class? -base-kind dimension-type* modifier?
base-kind      : Wildcard | Type | range-type | length-type | list-kind | set-kind | tuple-kind | fn-kind | TypeVariable
array-kind     : -base-kind dimension-type+
list-kind      : '[' base-kind? ']'
set-kind       : '{' base-kind? '}'
tuple-kind1    : '..' | kind
tuple-kind     : '(,)' | '(' [ -tuple-kind1 ( ',' >> -tuple-kind1 )* ]  ')'
fn-kind        : '(->)' | '(' kind >> '->' ( >> kind >> '->' )*  >> kind ')'
op-kind        : ( Wildcard | Operation ) fn-kind

% Modularisation
file           : module | namespace
namespace      : form

% Implementation
module         : (, declaration)+ .
declaration    : val | instances | fn | op | behaviour | fault | notation | data | system | unit | dimension

fault          : 'fault' >> Fault >> '::', < Type, values?

system         : 'unit' ^ 'system' < ^ System >> '::', '=', (ratio,)*
ratio          : 'ratio' < ^ Ratio >> '::', '[', equation, (',', equation,)* ']' .
equation       : literal >> '=' >> literal

% Values
val            : 'val' < ^ Constant >> '::' < >> [type >>] '=' >> expr

data           : 'data' < ^ Data >> '::', (record | type), format*, enumeration?
record         : '('<, field, (',', field,)* ')'
field          : type ^ Field
format         : ':'<, ('#'< -pattern '[]'? | '"' -pattern '"' ),
pattern        : '(' ( (type | literal)+','?,)+ ')'
enumeration    : '=', form

dimension      : 'dimension' < ^ -primitive, enumeration?
unit           : 'unit' < ^ -primitive
primitive      : Type < >> ['[' Symbol ']'] >> '::', ((Atom ^)*):aspects  [Type >> values?], format*

% Somewhat abstract data types
notation       : 'notation' < ^ Notation >> '::', type?, [ '=', '{', type, (',', type,) '}' ]:members

behaviour      : 'behaviour' < ^ Behaviour >> '::', [Behaviour, (',', Behaviour,)] ['=', '{', Operation, (',', Operation,)* '}']

% Functions
op             : 'op' < ^ Operation >> ['[' Operator ']'] >> '::', Operation?, signature

fn             : ('fn'|'proc') < ^ Function >> ['[' Operator ']'] >> '::', signature?, implementation, [ where ] 
signature      : -descriptor | '('< >> -descriptor >> ')'
descriptor     : ( parameter >> '->' >> )+ type
parameter      : type ^ -Identifier:name
implementation : ['\' >> expr >> ':' .] ('\' >> -vector >> '\', '=' >> expr . )* [['\' >> '\'] '=' >> expr . ]
where          : 'where' < , clause >> (clause >> )*
clause         : variable | specialisation
variable       : type ^ Identifier >> '=' >> expr .
specialisation : bind | promotion
promotion      : type >> '~>' >> Type .
bind           : Function >> '~>' >> Operation (>> type)* .

% Expressions
vector         : expr (, {',' ';'}?, expr )*
expr           : form ( >> form )*
form           : eval | tuple | list | set | comment | term
eval           : '(:=', -vector, ')'
inline         : '^' Function
tuple          : '()' | '(', -vector, ')'
list           : '[]' | '[', -vector, ']'
set            : '{}' | '{', -vector, '}'
comment        : '%' .. '%'
term           : Wildcard | Atom | values | literal | Artifact | Constant | Operator | Identifier | inline | Type | Fault | Variable | TypeVariable