% Fragments
Dashed         : { '-' 'a' - 'z' 9 }* { 'a' - 'z' 9 }?
Verb           : 'a' - 'z' -Dashed?
Noun           : 'A' - 'Z' { @ '-' } { @  9 }*

% Identifiers
Field          : { 'a' - 'z' 9 } -Dashed?
Constant       : ':' -Field
Variable       : -Field '''*

Operation      : -Verb '?'?
Function       : -Verb '?'? '''*
Module         : -Verb
Library        : -Verb
Namespace      : -Verb
Fault          : -Verb '!'

TypeVariable   : 'A' - 'Z' 9?
Protocol       : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Simple         : Unit | Dimension
Compound       : Data | Protocol | Notation
Value          : Simple | Compound

% Operators
Operator       : (OperatorSymbol)x1-3
OperatorSymbol : { '.' '+' '-' '/' '*' '=' '>' '<' '&' '|' '^' }

% Symbols
Measure        : { @ UnitSymbol }+
UnitSymbol     : { ''' '%' '$' '€' '@' '/' '°' '"' ' ' }

% Literals
Literal        : LiteralLogic | LiteralText | LiteralBinary
LiteralLogic   : ''' (9+ | .. Measure)
LiteralText    : '"' !'"'* '"'
LiteralBinary  : '#' ('b' 1+ | 'o' 7+ | 'd' 9+ | 'x' #+ )

Range          : RangeLiteral | RangeConstant
RangeLiteral   : Literal [ >> '..' >> Literal ] | '..' >> Literal
RangeSet       : '{' >> Literal >> (',' >> Literal >> )* '}'
RangeConstant  : Constant [ >> '..' >> Constant ] | '..' >> Constant

% References
Reference      : Variable | Constant | Literal

% Types
Type           : TypeBase TypeDimension? TypeVariant? | TOp
TypeVariant    : { '!' '?' '~' '*' }
TypeBase       : Value | TList | TSet | TTuple | TFn | TypeVariable
TypeDimension  : '[' 9* ']'
TArray         : TypeBase TypeDimension
TList          : '[' TypeBase ']'
TSet           : '{' TypeBase '}'
TTuple         : '(' [ Type ( ',' >> Type )* ] ')'
TFn            : '(' Type >> '->' ( >> Type >> '->' )* >> Type ')'
TOp            : Operation TFn

% Type Variables / Kinds
instances      : 'instances', TypeVariable, '::', Operation*, Kind
Kind           : KindBase KindDimension? TypeVariant? | KOp
KindBase       : '_' | TypeBase | KList | KSet | KTuple | KFn
KindDimension  : '[' 9* [ '-' 9* ] ']'
KArray         : KindBase KindDimension
KList          : '[' KindBase ']'
KSet           : '{' KindBase '}'
KElement       : '..' | Kind
KTuple         : '(,)' | '(' [ KElement ( ',' >> KElement )* ]  ')'
KFn            : '(->)' | '(' Kind >> '->' ( >> Kind >> '->' )* >> Kind ')'
KOp            : ( '_' | Operation ) KFn

% Modularisation
file           : (library | namespace | module) ,
library        : 'library', Library, '::', '{', Module, (',', Module,)* '}'

namespace      : 'namespace', Namespace, '::', import*, auto*, invariant*
import         : '-use' ~ ['shared' ~] ['strict' ~] Library >> include?,  alias?
include        : ':' >> Module (>> Module)* >> \n
alias          : 'where', ( Value >> '=' >> Value, | Operation >> '=' >> Operation, )+

module         : 'module', Module, '::', auto*, invariant*, feature+
feature        : (val | instances | fn | op | protocol | fault | notation | data | unit | dimension | system),

auto           : '-auto' ^ deduction
deduction      : bind | refinement
refinement     : ( '[]' | '{}' | Value | TTuple | TArray ) >> '=<>' >> Value
bind           : Function >> '=>' >> Operation (>> Type)*

invariant      : '-invariant' ^ Value >> '!' >> Function

% Implementation
val            : 'val' >> Constant >> '::' >> Type >> '=', expr

data           : 'data' ^ Data >> '::', '(', element, (',', element,)* ')' , format*, enumeration?
element        : Type >> Field

format         : '<->', ( TTuple | TArray | Data ),

enumeration    : '=', ( item-set | item-list | item-range )
item-set       : '{', item, (',', item,)* '}'
item-list      : '[', item, (',', item,)* ']'
item-range     : Constant >> '..' >> Constant
item           : Constant >> expr?

dimension      : 'dimension' >> simple, enumeration?

unit           : 'unit' >> simple

simple         : Simple >> ['[' Measure ']'] >> '::', Simple? >> Range?, format*

system         : 'unit' ^ 'system' ^ System >> '::', '{', ratio, (ratio,)* '}'

ratio          : 'ratio' ^ Ratio >> '::', '(', Unit, (',', Unit,)* ')', '=', '[', equation, (',', equation,)* ']'
equation       : Literal >> '=' >> Literal

fault          : 'fault' >> Fault >> '::', Value, Range?

notation       : 'notation' >> Notation >> '::', Type?, [ '=', '{', Type, (',', Type,) '}' ]

fn             : 'fn' >> Function >> ['[' Operator ']'] >> '::', signature, conditional*, return, [ 'where', term >> \n (term >> \n)* ]
signature      : signature1 | '(' signature1 ')'
signature1     : parameter >> '->' >> ( parameter >> '->' >> )* Type
parameter      : Type >> Variable:name
conditional    : '=', expr, '?', expr
return         : '=', expr
term           : variable | deduction
variable       : Type >> Variable >> '=' >> expr

op             : 'op' >> Operation >> ['[' Operator ']'] >> '::', Operation?, signature

protocol       : 'protocol' >> Protocol >> '::', '{', Operation, (',', Operation,) '}'

expr           : tuple | list | set |  group | Reference 

invoke         : expr ' ' ( Operator | Function ) [ expr (,',', expr) ]
specialisation : expr >> '=>' >> ( Type | Operation )

group          : '(', expr, ')'
list           : '[]' | '[', expr, (',', expr,) ']'
set            : '{}' | '{' expr, (',', expr,) '}'
tuple          : '()' | '(' expr, (',', expr,) ')'