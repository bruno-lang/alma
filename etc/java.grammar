file =  -header, members .
header = package, imports
comment = ('/*' .. '*/'):doc | ('//' .. .):inline
package = , comment*, 'package', -identifiers, ';'
imports = (, import)*
import = comment*, 'import', < 'static'?, type, ';' 
members = -member (, -member)*
member = comment | class | interface | enum | constructor | method | field

modifiers = (, -modifier)*
modifier = ('public'):public | 'protected' | ('private'):private | ('static'):static | ('final'):final | 'abstract' | 'transient' | 'synchronized' | 'volatile'

class = modifiers?, 'class' ~ < identifier:name, [generic,] extends?, implements?, -type-block
interface = modifiers?, 'interface'~ < identifier, extends?, -type-block
enum = modifiers?, 'enum' ~ < identifier, implements?, '{', enumeration, members?, '}'
extends = 'extends', < type
implements = 'implements', < type

eos = !';'+ ';'
enumeration = [( identifier, ['(', args, ')',] ','?,)* ';']

primitive = 'int' | 'char' | 'float' | 'boolean' | 'double' | 'long' | 'void' | 'byte' | 'short'

type = ( primitive | -identifiers ) '[]'* ['...']
generic = '<', [generic-type, (',', generic-type,)*] '>'
generic-type = type [ generic ]

type-block = '{', members?, '}'

annotations = annotation (, annotation)*
annotation = '@'type ['(' .. ')']

constructor = modifier?, identifier, '(', -params, ')', block
params = [ param (,',', param)* ]
param = [modifier ~] generic-type, identifier:name

method = annotations?, modifiers?, generic-type, identifier:name, '(' < , -params, ')', [throws,] (';' | '{', statements?, '}')
field = modifiers?, generic-type, identifier, ['=', (array | args), ] ';' 

throws = 'throws', < type (,',', type)*

statements = -statement (, -statement)* 
statement = comment | if | for | while | try-catch | return | switch | do | throw | break | continue | label | assign, ';' | expression, ';'
if = 'if', < '(', expression, ')', block [, 'else', < block ]
while = 'while', < '(', expression, ')', block
do = 'do', < -block, 'while', '(', expression, ')'
for = 'for', < '(', (counter | each) , ')', block
counter = assign, ';', expression, ';', expression
each = generic-type ~ identifier, ':', expression
try-catch = 'try', < -block (, 'catch', '(', type ~ identifier:name,')', -block)* [, 'finally', -block]
switch = 'switch', < '(', expression, ')', '{', (case ,)* '}'
case = 'case' ~ < identifier,':', -block | 'default', ':', < -block
break = 'break'[~ identifier],<';'
continue = 'continue'[~ identifier],<';'
label = identifier,':'
throw = 'throw' ~ < expression, ';'
block = '{', statements?, '}' | statement
return = 'return' ~ < expression, ';'
assign = [modifier ~] [generic-type ~ ] var, '=' < , (array | expression)
invoke = (ref '.')* identifier:name, '(' < , args, ')',
new = 'new' ~ < generic-type, ( '(', args, ')' | (('[', [expression,] ']')+ ):array | '{', args ,'}' )
var = (('this' | 'super' | ref) '.', )* ref  
ref = identifier ( '[', expression, ']' )* 

args = [ expression (,',', expression)* ]
expression = -expr1 (, (operator | '.'), -expr1 )* [, conditional]
conditional = '?' < , expression:then, ':', expression:else
expr1 = cast? prefix?, (new | literal | invoke | var | group) postfix?
group = '(', expression, ')'
cast = '(',generic-type,')'
array = '{', args, '}'

literal = string | char | -number
string = '"' ({ !'"' !'\' }+ | '\' $ )* '"'
char = ''' '\'? $ '''
number = hex | binary | long | float | double | int
int = sign 9+
long = sign 9+ {'l' 'L'}
float = sign 9* '.' 9* {'f' 'F'}
double = sign 9* '.' 9* {'d' 'D'}
hex = '0x' { 9 'A'-'F' 'a'-'f'}+
binary = '0b' 1+
sign = { '-' '+' }?
operator = {'=' '>' '<' '!' '*' '-' '+' '/' '&' '|' '%'}x1-3
prefix = '-'x1-2 | '+'x1-2 | '!' | '~'
postfix = '-'x2 | '+'x2

identifier = { @ '_' '$' } { @ 9 '_' '$' }*
identifiers = identifier ('.' identifier)*