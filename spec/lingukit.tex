\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{color}
\usepackage{inconsolata}

\newlist{rulelist}{description}{2}
\setlist[rulelist]{leftmargin=6.5em,style=nextline,font=\bf\tt}

\lstset{
  basicstyle=\footnotesize\ttfamily,
  breaklines=true,
  keywordstyle=\color{blue}
}

\lstdefinelanguage{Lingukit}{
  keywords={:,|},
  sensitive=true,
  alsoletter={:|},
  keywordstyle=\color{blue}
}

\begin{document}
\lstset{language=Haskell}
\title{Lingukit}
\author{Jan Bernitt}
\date{\today}
\maketitle

\begin{abstract}
\noindent Lingukit is a concrete formal grammar to describe the syntax of another target grammar. It is close to the model of \textit{Grammars as Data and Solvers} and has concise declarative syntax similar to \texttt{BNF}.
\end{abstract}

\section{Quick Start Guide}
\subsection{Matching Bytes}
The grammar is designed to be used on \texttt{UTF-8} encoded input. Therefore the basic unit of a character is a \texttt{byte}.

The simplest way to match one or more bytes is to literally give a fixed sequence of characters to match. This is done by enclosing them in single ticks \texttt{'} like \texttt{'a'} for literally a or \texttt{'keyword'} for literally keyword. No escaping is supported or necessary - a single tick \texttt{'} itself is given similarly \texttt{'''}.
\begin{verbatim}
    literally-a = 'a'
    literally-keyword = 'keyword'
\end{verbatim}
Non ASCII characters or white-space should instead be given as a uni-code literal in the form \verb!\uXXXX!

To match subsets of characters a few different constructs can be used and combined.
\begin{verbatim}
    digit = '0'-'9' % range
\end{verbatim}

\subsection{Matching Structure}
A rule's patter or structure can be described using the common generic building blocks of information processing:
\begin{itemize}
\item iteration
\item sequence
\item selection
\item (plain blocks)
\end{itemize}

TODO completion

\subsection{Capturing Matches}
By splitting a grammar into named rules also the blocks of the resulting parse-tree are described.
\begin{verbatim}
    foo = bar baz
\end{verbatim}
The above rule will capture a tree structure like this
\begin{verbatim}
    foo
        bar
        baz
\end{verbatim}

Also individual elements in a rule declaration can be named inline:
\begin{verbatim}
    range = number:low '-' number:high
\end{verbatim}    
    
The above rule aliases the rule number to low and high. The resulting parse-tree will look like
\begin{verbatim}
    range
        low
        high
\end{verbatim}

Lastly rules can be referenced without also capturing them. This is used to reuse patterns that themselves do not describe a complete interesting value.
\begin{verbatim}
    number = -digit+
\end{verbatim}
The above rule says that a number consists of 1 or more digits but by using minus \verb!-! prefix on the rule's name so this block isn't captured itself. The resulting parse-tree will just contain one token number. As a convention also all rules having a name starting with a \verb!\! will not be captured. This is e.g. utilised to declare a rule named \verb!\n! that can be used as an alias to the \verb!\u000A! without capturing such a rule.


\section{Grammar Specification}

\subsection{Names and References}
A name is any sequence of ASCII letters (both lower and upper), ASCII digits, underscore \verb$_$ and dash \verb$-$. In addition a name may start with backslash \verb$\$. Names starting with dash \verb$-$ or backslash \verb$\$ are never captured. When referencing a rule the reference name may use a starting dash to not capture even thou the referenced rule does not start with a dash.

\subsection{Short-hands}
There is some \textit{syntactic sugar} that does not add more expressiveness but better readability by giving frequently used patterns a short-hand syntax.

\paragraph*{Occurrence}
\begin{itemize}
\item \verb!+ = x1+!
\item \verb!* = x0+!
\item \verb!? = x0-1!
\item \verb![XYZ] = (XYZ)? = (XYZ)x0-1!
\end{itemize}

\paragraph*{Sets of Characters}
\begin{itemize}
\item \verb!9 = '0'-'9'!
\item \verb!7 = '0'-'7'!
\item \verb!1 = '0'-'1'!
\item \verb!# = { 9 'A'-'F'} = { '0'-'9' 'A'-'F'}!
\item \verb!@ = { 'a'-'z' 'A'-'Z' }!
\item \verb!$ = { \u0000-\u7FFFFFFF }! (that is any UTF-8)
\end{itemize}

\paragraph*{White-space}
\begin{itemize}
\item \verb$_ = \s = { \t \n \r ' '}$
\item \verb$, = _* = { \t \n \r ' '}*$
\item \verb$~ = _+ = { \t \n \r ' '}+$
\item \verb$. = >>* { \n \r }+ >>*$\footnote{this is not fully equivalent as the pattern allows that CR/LF do not occur if the end of the file is reached}
\item \verb$>> = { \t ' ' }$
\end{itemize}

\newpage
\lstinputlisting[language=Lingukit,caption={\texttt{Lingukit} given in its own syntax}]{../etc/lingukit.grammar}

\section{File Format Specification}

\end{document}