<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="lingukit">lingukit</h1>
<p><em>easy understandable parsing</em></p>
<p>(this document is available as <a href="https://github.com/bruno-lang/lingukit/blob/master/README.pdf">PDF</a> or <a href="https://github.com/bruno-lang/lingukit/blob/master/README.html">HTML</a> for printing, source is markdown)</p>
<h4 id="self-experiment">Self-Experiment</h4>
<ol style="list-style-type: decimal">
<li>Pretend you don't know anything about parsing (theory/practice).</li>
<li>Imagine a language!</li>
<li>Think: How would one read and understand its elements or structure?</li>
<li>Picture how you could formalise this to let a machine do what you just did in your mind.</li>
</ol>
<p>Now, was any of the madness you <strong>do</strong> know about parsing relevant in this?</p>
<p>Imagining and design languages is real fun - making a machine parse it in the reality of <em>common wisdom</em> parsing however often is exhausting if not frustrating.</p>
<p>I chose to ignore and <em>forget</em> this wisdom and explore parsing once again.</p>
<h4 id="a-journey-from-grammars-to-parse-trees">A Journey from Grammars to Parse-Trees</h4>
<p>We are willing to write a grammar so we can use a parser that gives us parse-trees for input source files.</p>
<pre><code>    (Grammar -&gt; Parser) -&gt; Source -&gt; ParseTree</code></pre>
<p>That's basically how we used to think of it - because we made the assumption that we need a specific parser for a specific grammar. While this appears <em>natural</em> it is a fallacy. It is enough to have <strong>one parser</strong> that given a grammar can parse a source in accordance with the grammar.</p>
<pre><code>    Parser -&gt; (Grammar, Source) -&gt; ParseTree</code></pre>
<p>Now we <em>only</em> have to write a grammar that we as well as the parser do understand. Although we also need to understand how the parser processes the grammar so that we can make it do what we meant to say. This sounds a lot like giving instructions - doesn't it? (<em>see also:</em> Damian Conway - <a href="http://www.infoq.com/presentations/regex">Everything You Know About Regexes Is Wrong</a>)</p>
<p>Following that thought a parser is sort of a <em>virtual machine</em> that - given <em>instructions</em> in form of a grammar - can process input <em>programs</em> what produces parse-trees as output.</p>
<p>Fortunately we are used to programming, to give instructions and reason about their implications and conditions. As soon as we have learned the <em>machine's primitives</em> a grammar can be written like a program. No special parsing theory or tool behaviour knowledge is required following this path.</p>
<h2 id="examples-reference-implementation">Examples &amp; Reference Implementation</h2>
<p>See in the <a href="https://github.com/bruno-lang/lingukit/tree/master/examples"><code>examples</code></a> folder for actual grammars. There is a reference implementation in Java. The Dart implementation has not been updated lately with the latest changes.</p>
<h2 id="instructions">Instructions</h2>
<p>The following describes 8 essential and 3 optional instructions of a underlying parser's <em>machine language</em> through a surface syntax called <code>lingukit</code>, that maps roughly 1:1 to <em>machine instructions</em>.</p>
<p>Executing a instruction results either in a new <em>matched</em> input position or a <em>mismatch</em> position. The <em>execution context</em> is the current position and the parse-tree build so far.</p>
<h3 id="matching-characters">Matching Characters</h3>
<p><code>lingukit</code> is designed to match bytes (of UTF8 characters) but the principle can be applied to any <em>basic unit</em>.</p>
<hr />
<h4 id="literal">0 Literal</h4>
<p>Tests if input at current position literally matches a constant of one or more bytes given as a string literal with single quotes <code>'</code>.</p>
<pre><code>    &#39;a&#39; &#39;what we are looking for&#39;</code></pre>
<p>Alternativly a unicode character can be given by its code-point value in hexadecimal notation prefixed with <code>U+</code> (here <code>\n</code> what is decimal 10):</p>
<pre><code>    U+000A</code></pre>
<p><em>Instruction Pseudo-code:</em></p>
<pre><code>    if (input starts-at position == literal)
        continue at position + length(literal)
    else
        mismatch at position</code></pre>
<hr />
<h4 id="terminal">1 Terminal</h4>
<p>Tests if input at current position is contained in a set of Unicode code-points. Sets are given in curly braces by single characters and character ranges:</p>
<pre><code>    {&#39;a&#39; &#39;b&#39; &#39;c&#39;} {&#39;a&#39;-&#39;z&#39;} {U+0041-U+005A}</code></pre>
<p>Of course literals used in set definitions must be single code-point literals. Sets can also exclude characters using <code>!</code> <em>NOT</em> in front of a character or character-range in from <code>{low}-{high}</code>.</p>
<pre><code>    {!&#39;?&#39;} {!&#39;0&#39;-&#39;9&#39;}</code></pre>
<p>There are also a couple of short hands (see syntactic sugar) that are not quoted. For example <code>Z</code> is the short-hand for <code>{'A'-'Z'}</code>. Such short hands or named sets (as described in capturing section) may as well appear within another set definition what is combined with <em>OR</em> usually or as <em>AND</em> in case of exclusion set.</p>
<pre><code>    { Z &#39;0&#39;-&#39;9&#39; }</code></pre>
<p><em>Instruction pseudo-code:</em></p>
<pre><code>    if (character-set contains (input code-point at position))
        continue at position + length(code-point at position)
    else
        mismatch at position</code></pre>
<h3 id="matching-words">Matching <em>Words</em></h3>
<hr />
<h4 id="sequence">2 Sequence</h4>
<p>A sequence of instructions is - surprise - given by writing the instructions one after another (separated by white-space where ambiguous otherwise).</p>
<pre><code>    &#39;a&#39; &#39;b&#39; &#39;c&#39;</code></pre>
<p>Parentheses can be used to group sequences for nesting structures.</p>
<pre><code>    (&#39;a&#39; &#39;b&#39;) &#39;c&#39;</code></pre>
<p>If one instruction in a sequences results in a mismatch the sequence results in a mismatch as well.</p>
<p><em>Instruction pseudo-code:</em></p>
<pre><code>    cursor = position
    foreach instruction in sequence
        cursor = instruction exec (input, cursor) 
        if (is-mismatch(cursor))
            mismatch at position
    continue at cursor</code></pre>
<hr />
<h4 id="iteration">3 Iteration</h4>
<p>Executes an instruction several times (between a minimum and a maximum). The iteration count is directly appended to the repeated instruction using <code>x{min}-{max}</code>. Some examples:</p>
<pre><code>    &#39;a&#39;x1-2 &#39;b&#39;x4 (&#39;c&#39; &#39;d&#39;)x3 {&#39;0&#39;-&#39;9&#39;}x2-4</code></pre>
<p><em>Instruction pseudo-code:</em></p>
<pre><code>    match = position
    do maximum times
        cursor = instruction exec (input, match)
        if (is-mismatch(cursor))
            if (done less than minimum times)
                mismatch at position
            else 
                continue at match
        else
            match = cursor
    continue at match</code></pre>
<hr />
<h4 id="selection">4 Selection</h4>
<p>Tests a sequence of alternatives until the <strong>first match</strong>. If no alternative matches the selection is a mismatch. Note that this is not a logical <em>OR</em>, the first matching instruction is continued, the sequence of alternatives is relevant. This is important to be able to reason about what will happen for a certain input sequence.</p>
<p>Alternatives are separated with the vertical bar <code>|</code>.</p>
<pre><code>    &#39;ab&#39; | &#39;cd&#39;</code></pre>
<p><em>Instruction pseudo-code:</em></p>
<pre><code>    furthest-mismatch = mismatch at position
    foreach instruction in sequence
        cursor = instruction exec (input, cursor)
        if (is-match(cursor))
            continue at cursor
        else  
            furthest-mismatch = furthest(cursor, furthest-mismatch)
    mismatch at furthest-mismatch</code></pre>
<hr />
<h4 id="completion">5 Completion</h4>
<p>Consumes the input until the completed instruction matches at the current position. So instead of describing what to match the input is processed until a specific end is found matched through any another simple or composed instruction.</p>
<p>A completion is indicated by two dots <code>..</code> followed by the end instruction. Here an example to match XML comments:</p>
<pre><code>    &#39;&lt;!--&#39; .. &#39;--&gt;&#39;</code></pre>
<p><em>Instruction pseudo-code:</em></p>
<pre><code>    end = length(input)
    while (position &lt; end)
        cursor = end-instruction exec (input, position)
        if (is-mismatch(cursor))
            position = increment(position)
        else
            continue at position
    mismatch at end</code></pre>
<p>Completions can be <em>expensive</em> in case the end-instruction is not a a literal or terminal as the position is incremented one by one.</p>
<h4 id="capturing-matches">Capturing Matches</h4>
<p>Instructions 0-5 control the parsing process by instructing the parser what or how to match input.</p>
<p>The next two instructions 6 and 7 are used to a) shape the resulting parse-tree and b) allow to form reusable compositions and recursion.</p>
<hr />
<h4 id="reference">6 Reference</h4>
<p>Combinations of instructions are <em>assigned</em> to a named rule.</p>
<pre><code>    comment = &#39;&lt;!--&#39; .. &#39;--&gt;&#39;</code></pre>
<p>Such rules can be referenced on the right hand side of another rule through their name.</p>
<pre><code>    xml = comment | element</code></pre>
<p>The rule <code>xml</code> <em>reuses</em> the rules <code>comment</code> and <code>element</code> as alternatives of a selection.</p>
<p>References can always be resolved before a grammar is actually used to control a parser. In practice they might just be used to initially describe recursion and reuse in a grammar through a instruction. Later on they might not appear any longer in an actual grammar instance (the runtime representation) as they have been substituted with the actual referenced rule. However, this can be implemented either way.</p>
<p><em>Instruction pseudo-code (when resolved during parsing):</em></p>
<pre><code>    referenced-instruction = context resolve reference-name
    continue at referenced-instruction exec (input, position)</code></pre>
<hr />
<h4 id="capture">7 Capture</h4>
<p>Records the start and end position of the captured <strong>rule instruction</strong> by pushing a frame onto a stack (a the parse-tree in a sequential form).</p>
<p>Rules (simple or complex named instructions) also serve for the purpose to <em>mark</em> a section of interest that should be reflected in the resulting parse-tree. By assigning instructions to a identifier the given combination of instructions is of interest to us and will be represented in the parse-tree by a node with the identifier given.</p>
<pre><code>    identifier = {instructions}</code></pre>
<p>A matched section becomes a stack frame (tree node) describing the rule that matched (most importantly its identity/name) as well as the start and end position of the match. The stack will itself add nesting depth information so that a sequence of frames can be looked at as a tree.</p>
<p>If combinations of instructions are not of interest as a complete element but should be used as a fragment to be able to reuse partial structures a reference to a fragment is prefixed with the minus <code>-</code> sign.</p>
<pre><code>    upper = {&#39;A&#39;-&#39;Z&#39;}
    lower = {&#39;a&#39;-&#39;z&#39;}
    first-name = -upper -lower+
    last-name = -upper -lower+
    full-name = first-name &gt;&gt; last-name</code></pre>
<p>As <code>upper</code> and <code>lower</code> are prefixed for <code>first-name</code> and <code>last-name</code> rule they will not appear in the result tree. <code>first-name</code> and <code>last-name</code> on the other hand will become tree-nodes as they are referenced by not prefixed. The resulting tree for <code>full-name</code> will have the structure:</p>
<pre><code>    full-name
        first-name
        last-name</code></pre>
<p><em>Instruction pseudo-code</em></p>
<pre><code>    stack open frame (rule, position)
    end = captured-instruction exec (input, position)
    if (is-mismatch)
        stack pop
    else
        stack close frame at end
    continue at end</code></pre>
<h3 id="additional-instructions">Additional Instructions</h3>
<p>There are 3 more instructions that are not essential for the concept to work but that can improve and extend its functionality.</p>
<hr />
<h4 id="pattern">8 Pattern</h4>
<p>Patterns are abstract basic units. The instructions asks a pattern how many bytes at the current input position are matching.</p>
<p><code>lingukit</code> has a fixed set of patterns exclusively used for processing white-space but the principle could be applied for any purpose. The patterns used by <code>lingukit</code> are all expressible through the essential instructions what ensures interoperability also for those parser platforms that do not support patterns at all.</p>
<ul>
<li>Indent: <code>&gt;</code> = <code>{' ' \t}*</code> (may be indenting white-space; on same line)</li>
<li>Separator <code>&gt;&gt;</code> = <code>{' ' \t}+</code> (must be indenting white-space; on same line)</li>
<li>Gap: <code>,</code> = <code>_*</code> (may be white-space)</li>
<li>Pad: <code>;</code> = <code>_+</code> (must be white-space)</li>
<li>Wrap: <code>.</code> = <code>&gt;&gt; \n &gt;&gt;</code> (must be line wrap)</li>
</ul>
<p><em>Instruction pseudo-code:</em></p>
<pre><code>    length = pattern length-of-match(input, position)
    if (length &gt;= 0)
        continue at postion + length
    else
        mismatch at position</code></pre>
<p>Patterns are mostly a performance optimisations as almost all could similarly be modelled using combinations of other instructions.</p>
<p><strong>Obs!!</strong> Different parsers might support different sets of named patterns so they should be used with caution. For the same reason Regexes should not be included as different platforms have different support and interpretation of regular expressions what would undermine the interoperability of the parser/grammars.</p>
<hr />
<h4 id="decision">9 Decision</h4>
<p>This additional instruction is used as an element in a sequence to mark the position in that sequence where it is clear that the sequence is meant and should fully match. If the sequence matched up to the decision but mismatches at a later point the parsing has failed, no other alternatives should or have to be tried. The syntax error is at the mismatch position in the sequence.</p>
<p>A decision position is marked with an ampersand <code>&amp;</code> sign. In a JSON grammar the <code>array</code> rule might be given as:</p>
<pre><code>    json ::= object | array | bool | null | string | number
    array ::= &#39;[&#39;&amp;, -elements?, &#39;]&#39;</code></pre>
<p>An <code>array</code> is the second alternative for a <code>json</code> element. If the element starts with an square bracket <code>[</code> we can be sure it has to be an array and the rule should fully match, otherwise the JSON is malformed.</p>
<p><em>Instruction pseudo-code (modification only):</em></p>
<p>A simple way to implement the instruction is to modify the machine behaviour of the sequence instruction. The <em>mismatch</em> path throws an exception in case the sequence had a decision and has been matches beyond it.</p>
<pre><code>    if (sequence decision-index &lt; current-element-index)
        raise exception &quot;parseing failed&quot;
    else
        mismatch at position</code></pre>
<p>The decision instruction is a very useful instruction to be able to give helpful feedback in case of malformed input. Especially recursive data formats like JSON will otherwise often result in bad feedback as all alternatives will be tried first before the parsing fails whereby the parse-tree will be reduced to nothing when the mismatch travels up the parser's call stack.</p>
<hr />
<h4 id="look-ahead">10 Look-ahead</h4>
<p>The described parser <em>machine</em> has no different parsing modes as described so far as greedy/non-greedy is a source of confusion and unintuitive complexity.</p>
<p>Especially grammars for already existing languages might be ambiguous in a way that can just be resolved when looking <em>ahead</em> in the input stream without actually processing it as usual. The look-ahead instruction does this. It is used as last element in sequences to describe how we expect the input to continue to make the sequence match but without counting that tail as part of the match for the sequence.</p>
<p>Look-ahead is a group prefixed with a tilde <code>~( {look-ahead-instructions} )</code>.</p>
<pre><code>    a = (&#39;a&#39; &#39;sequence&#39; &#39;continues&#39; ~(&#39;with&#39; something) )       
    b = (&#39;a&#39; &#39;sequence&#39; &#39;continues&#39; ~(&#39;with&#39; nothing) )     </code></pre>
<p>As the start of both <code>a</code> and <code>b</code> is identical we cannot tell which of them we should choose. The look-ahead can than be used to distinguish them without <em>consuming</em> further input.</p>
<p><em>Instruction pseudo-code (modification only):</em></p>
<p>The instruction is also easiest implemented by modifying the sequence behaviour of the parser machine. Everything that has to be done is to check at the end of the loop iterating over the elements of the sequence if the currently processed instruction was of type <em>look-ahead</em>. In that case the end position is not updated but the the flow directly continues with the end position thus far (before the look-ahead instruction).</p>
<pre><code>    if (current-instruction type == look-ahead)
        continue at end
    else
        end = cursor</code></pre>
<hr />
<h3 id="comments">Comments</h3>
<p><code>lingukit</code> allows to write comment lines. A comment line has to start with the percent sign <code>%</code> and ends at the end of the line.</p>
<pre><code>    % a comment</code></pre>
<p>Comments have no further function or consequence than to add some prose to a grammar file.</p>
<h2 id="syntactic-sugar">Syntactic Sugar</h2>
<h4 id="white-space-characters">White-space Characters</h4>
<p>As there is no escaping for quoted literals white-space has to be defined using the code-point syntax. For better readability there are the following short-hands (note that no quotes are used as for literals!):</p>
<ul>
<li>LF (Line Feed): <code>\n</code> = <code>U+000A</code></li>
<li>CR (Carriage Return): <code>\r</code> = <code>U+000D</code></li>
<li>HT (Horizontal Tabulation, tab) : <code>\t</code> = <code>U+0009</code></li>
</ul>
<h4 id="character-sets">Character Sets</h4>
<p>The <code>lingukit</code> syntax offers several short hands for commonly occurring character sets that can be used everywhere a set is valid.</p>
<ul>
<li>ASCII White-space: <code>_</code> = <code>{ U+0009 U+0013 U+0032 }</code></li>
<li>ASCII Letters (upper) = <code>Z</code> = <code>{'A'-'Z'}</code></li>
<li>ASCII Letters (lower) = <code>z</code> = <code>{'a'-'z'}</code></li>
<li>ASCII Letters (upper and lower): <code>@</code> = <code>{z Z}</code> = <code>{'a'-'z' 'A'-'Z'}</code></li>
<li>ASCII Numbers (hexa) = <code>#</code> = <code>{'0'-'9' 'A'-'F'}</code></li>
<li>ASCII Numbers (decimal) = <code>9</code> = <code>{'0'-'9'}</code></li>
<li>ASCII Numbers (octal) = <code>7</code> = <code>{'0'-'7'}</code></li>
<li>ASCII Numbers (binary) = <code>1</code> = <code>{'0' '1'}</code></li>
<li>Any Unicode code-point = <code>$</code> = <code>{ U+0000-U+7FFFFFFF }</code></li>
</ul>
<h2 id="implementation-notes">Implementation Notes</h2>
<h4 id="components">Components</h4>
<h5 id="parser">Parser</h5>
<p>The universal parser is very straight forward to implement in all common languages. The full pseudo-code is given with each instruction. Everything is based on very basic programming constructs usually known and mastered already on novice programmer levels. Depending on the host language a parser might be written in about 30-200 LOC.</p>
<h5 id="instructionsrules">Instructions/Rules</h5>
<p>Instructions are basically data records or abstract data types (depending on the host language support) with no <em>own</em> functionality regarding the parsing process. Their task is to make instruction details available for the parser machine to interpretate.</p>
<h5 id="parse-tree">Parse-Tree</h5>
<p>The parse tree is nothing more than a stack of <code>token</code> records of form:</p>
<pre><code>    token
        rule
        nesting-level
        start-position
        end-position</code></pre>
<p>This is similar or known as <em>index overlay parse-tree</em>. The level allows to view a sequence of records as tree.</p>
<h4 id="performance">Performance</h4>
<p>I never measured performance but I know that pushing and pulling frames off and from the stack is easy to implement so that is boils done to a few array store operations and integer arithmetic. The parser itself will only require relatively small stack frames for each nesting of instructions in the grammar. Further heap allocation is not needed. No other mutation than the parse-tree stack takes place.</p>
<p>The costs of comparing input with expectations have to be paid in any parser technology but the slim process that does all work in one step keeps this almost as essential as possible.</p>
<p>The way parsing works also implies that neither large grammars nor huge input affect the parsing in a non-linear manner. For the most part these do not matter. It should also be mentioned that in contrast to <em>common wisdom</em> parsing <code>lingukit</code> grammars will necessarily be written so that the first path that matches is taken (independently of the questions if other alternatives might match as well). This should keep mismatching alternatives short on average.</p>
<h4 id="tweaks-optimisations">Tweaks &amp; Optimisations</h4>
<p>Grammars are instruction trees, a data structure that can be analysed and optimised before it is used. Rules can be rewritten/replaced with simplified ones that will have the same behaviour. The most trivial example is to fuse multiple literals following each other in a sequence into one longer literal. The goal always is to reduce the nesting and size of the tree as smaller trees will result in less function calls, thus less stack frames and branching.</p>
<p>In principle this also enables to formulate grammars in inadequate way (e.g. using left recursion) as long as a rewriting procedure is known that transforms the instruction tree to a adequate one with the intended behaviour.</p>
<h4 id="extensions-modifications">Extensions &amp; Modifications</h4>
<p>The core idea is to use instruction trees and a parsing <em>machine</em> interpreting these. In principle both the essential as well as the optional instructions chosen for <code>lingukit</code> so far are not special in some way - they just were obvious useful to me. Each of them could be removed, other instruction not described or thought of here could be added.</p>
<h4 id="tooling">Tooling</h4>
<p>As grammars are data general tools can be build around them, interpreting their tree structure e.g. to convert it to other formats like a visual graph.</p>
<h4 id="non-textual-implementations">Non-Textual Implementations</h4>
<p><code>lingukit</code> is a somewhat BNF like syntax in which grammars are described as text that is parsed to tree from which a runtime grammar is build.<br />This additional step might not be worth it in some languages. In particular functional languages like Haskell or lisps are well suited to directly <em>formulate</em> a grammar's data structures in the host language itself. This approach is also used to bootstrap a parser for the <code>lingukit</code> language.</p>
<h2 id="q-a">Q &amp; A</h2>
<p>TODO</p>
<ul>
<li>Possible Languages?</li>
<li>Ambiguity?</li>
<li>Left-recursive, right recursive?</li>
<li>lexer, lexing, white-space?</li>
<li>terminal-, non-terminal tokens?</li>
<li>Memoization</li>
<li>multi-threading</li>
</ul>
<h2 id="what-more">What more?</h2>
<p>I later discovered <a href="https://www.youtube.com/watch?v=ZzsK8Am6dKU">Parsing with Derivatives</a> by Matthew Might from Stanford University having ideas for parsing that seam to be related to me but tackling it from the theoretically point of view with a lot of mathematical yadda yadda yadda.</p>
</body>
</html>
