% bruno (alma version) %

% Type Variant Symbols %
-Optional     = '?'
-Faulty       = '!'
-Transient    = '*'
-Self         = '~'
-Wildcard     = '_'
-InQuestion   = '?'

% Identifiers %
-Atom         = '`' \s^+
-Key          = '@' [Zs ',']^ [s ',{}()[]']^*
-Var          = '?' [zZ9 '-_' ]+

-Abbr         = \Z \9?
-Noun         = \Z [zZ '-']+ [zZ9 '!']* | '^' ['+-'9] \9*
-Verb         = \z [z9 '-']* [z9]? ['?!' \apostrophe]?
-Item         = [z '?']'.'

-label        = Verb ':'
-abstraction  = Noun (; Abbr)*
-name         = Noun | Key
-step         = Noun ':'

% Operators %
-Op           = ['+/*=><&-']
-Operator     = \Op [\Op '!?|']{0-2} | [\Op '|']{2-3}

% Literals %
-literal      = textual | numerical
-textual      = '"""' < .  ~@TEXT (. '"""') 
              | '"'   < ['"']^*@TEXT '"' 
              | \apostrophe < \apostrophe^*@TEXT \apostrophe
-numerical    = Number (Number | [s'?#"=><&|)].,;*\}']^)*
-Number       = ['+-']? \9+ (['.,'] \9+)*

% /////////////////////////////////////////////////////////////////////////////%

% Types %
-variant      = [\Faulty \Optional \Transient]

-dimension    = manualType | sliceType | channelType | arrayType
-manualType   = '[!' < scalarType ']'
-sliceType    = '[<' \lengthType < '>]'
-channelType  = ['[]'] ['<>']{1-2} < ['[]']
-arrayType    = '[' Noun ']' | '[' < \lengthType ']'
-lengthType   = spanType | scalarType
-spanType     = scalarType@MIN '-' scalarType@MAX
-scalarType   = \9+ | '*' | Abbr

-subrange     = '{' < subrangeType ('|' subrangeType)* '}'
-subrangeType = (valueType@MIN)? ('..' (valueType@MAX)?)?
-valueType    = literal | scalarType

-T            = shape | T_sum ( . '&' . T_sum)*
-T_sum      = (. '+' ,)? fullType (. '+' , fullType)*
-fullType     = '@'? \kind dimension* variant?
-kind         = Wildcard  | T_ordinal | T_list     | T_set  | T_fn
              | T_tuple   | namedType | lengthType | T_dots | Abbr
-namedType    = Noun subrange?
-T_dots       = '..'
-T_ordinal    = '#' < T
-T_list       = '[' < T ']'
-T_set        = '{' < T '}'
-T_fn         = '(->)'       | '(' (, T, (Verb, )? '->')+ , T   ')'
-T_tuple      = '()' | '(,)' | '(' field (['\;,']@X? , field )* ')'

-field        = (. label ,)? T ,
-shape        = '[]' | '{}' | '()' | '""' | Self | Atom | Key | literal

% /////////////////////////////////////////////////////////////////////////////%

% Expressions %
-expr         = term ( , term )*
-term         = expand   | tuple | list | set  | comment | implicit | inline 
              | Wildcard | Atom  | Key  | literal 
              | Operator | Var   | Verb | Noun | Abbr | InQuestion

-inline       = '\' Verb@FUNCTION
-expand       = '(:=' < \form  ')'
-implicit     = '\('  < \form  ')'
-tuple        = '('   < \form? ')'
-list         = '['   < \form? ']'
-set          = '{'   < \form? '}'
-comment      = '%'   <   ~   '%'
-form         = . expr ( . ',' ? . expr )* .

% Principles (these use ::) %
-module       = ( . \principle )+ .
-principle    = def | data    | when  | fn | family | sub
              | op  | concept | fault | on | ratio  | io  | comment

-fault        = 'fault'   < ; Noun,        '::' . namedType !
-ratio        = 'ratio'   < ; Noun,        '::' . literal,'=' , literal !
-def          = 'def'     < ; name,        '::' .         '=' . expr !
-io           = 'io'      < ; Noun,        '::' . T
-data         = 'data'    < ; name, attrs  '::' . T   ( . '{' . constants . '}')? (. '='   < . expr)?
-family       = 'family'  < ; Abbr, attrs  '::' . T   ( . '=' , abstractions   )? (. ':&:' < , ops )?
-concept      = 'concept' < ; abstraction, '::' .         '=' . set
-op           = 'op'      < ; Verb, attrs  '::' . T_fn
-fn           = 'fn'      < ; Verb, attrs  '::' . T_fn? . '=' case+                 ( ':?:' < (. variable)+)?
-sub          = 'sub'     < ; Verb, attrs  '::' . T_fn? . '=' case+                 ( ':?:' < (. variable)+)?
-when         = 'when'    < ; Noun,        '::' . T_fn  . effect* '..', transition* ( ':?:' < (. variable)+)?
-on           = 'on'      < ; Noun,        '::' . T_fn  . effect* '..', transition* ( ':?:' < (. variable)+)?

% lists of ... %
-attrs        = (Atom ; )* 
-ops          = Verb@OP     ( , ',' , Verb@OP)*
-abstractions = abstraction ( , ',' , abstraction)*
-constants    = constant    ( . '|' . < constant )* 

% assignments ... %
-constant     = '..' | name ( , ':' < , T)? (. '=' < . expr)?
-variable     =        Verb ( , ':' < , T)? , ('=' < . expr ! | ( . '|=' < , expr ! )+ )

% implementation body %
-case         =       . Item? , expr (, '|', expr)* !
-transition   =         step  , expr (, '|', expr)* !
-effect       = \9'.' , step? , expr !

