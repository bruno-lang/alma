% Fragments
Verb           : z { z 9 '-' }* { z 9 }?
Noun           : Z { @ '-' }+ { @  9 }*
Identifier     : -Verb {'?' '!'}?

% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '~'
SliceOf        : ':'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Specialisation : '~>'

% Identifiers
Wildcard       : '_'
Field          : -Verb
Constant       : -Noun
Atom           : '`'{ !_ }+
Key            : -KeyOf{ !Z !_ !',' }{ !_ !',' !'{' !'}' !'(' !')' !'[' !']'}*
Variable       : '?'{ @ 9 '-' '_' }+

Operation      : -Identifier
Function       : -Identifier

TypeVariable   : Z 9?
Behaviour      : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun
Process        : -Noun
Fault          : -Noun '!'

% Operators
Operator       : -OperatorSymbol { OperatorSymbol '!' '?' }x0-2
OperatorSymbol : { '+' '-' '/' '*' '=' '>' '<' '&' '|' }

% Unit Symbols
UnitSymbol     : { @ UnitLetter }+
UnitLetter     : { ''' '$' '€' '/' '°' '"' }

% Literals
literal        : conceptual | textual | binary
conceptual     : ''' ( (number['e'number:EXPONENT] UnitSymbol?) | ($ .. UnitLetter):VALUE )
textual        : '"""', (..):TEXT (, '"""') | '"' (!'"'*):TEXT '"'
binary         : '#'& ('b'& 1+ | 'o'& 7+ | 'x'& #+ | 'd'? 9+ ):NUMBER nb?
number         : ({'+' '-'}?):SIGN -numeral  ['/' -numeral]:DENOMINATOR nb?
numeral        : (9+ (','? 9+)*):DECIMAL ['.' 9+]:FRACTIONAL
% nota bene (call site literal comments)
nb             : '\' @+ 

values         : literal-set | literal-range | constant-range
literal-set    : '{' > literal > (',' > literal > )* '}'
literal-range  : literal [ > '..' > literal ] | '..' > literal
constant-range : Constant [ > '..' > Constant ] | '..' > Constant

% Types
variant        : { Faulty Optional Transient }
mode           : { TypeOf LazyOf KeyOf }
length-type    : 9+ | '*' | Type | TypeVariable
range-type     : length-type:MIN '-' length-type:MAX
dimension-type : '[' SliceOf? (range-type|length-type)? ']' | '..'
channel-type   : {'[' ']'} {'<' '>'}x1-2 & {'[' ']'}
stream-type    : {'<' '>'}
dimensions     : stream-type? dimension-type* [channel-type* dimension-type?]
type           : shape | op-type | mode? -base-type dimensions? variant?
base-type      : Type | list-type | set-type | tuple-type | fn-type | TypeVariable
list-type      : '['& -type? ']'
set-type       : '{'& -type? '}'
tuple-type     : '(' [ type (> ',' > type )* ] ')'
fn-type        : '(' type:INSTANCE > '->' ( > type > '->' )* > type:RETURN ')'
op-type        : Operation fn-type

% Shapes
shape          : '[]' | '{}' | '""' | Atom | Key

% Type Families / Variables
family         : 'family' & >> TypeVariable > '::', type-var [, 'as' as-behaviour (>',' as-behaviour)* ] [, 'with' > Operation (> ',' > Operation)*]
as-behaviour   : > Behaviour (>> TypeVariable)*
type-var       : shape | op-var | mode? -kind-var dimensions? variant?
kind-var       : Wildcard | Type | range-type | length-type | list-var | set-var | tuple-var | fn-var | TypeVariable
list-var       : '[' -type-var? ']'
set-var        : '{' -type-var? '}'
elem-var       : '..' | type-var
tuple-var      : '(,)' | '(' [ -elem-var (> ',' > -elem-var )* ]  ')'
fn-var         : '(->)' | '(' type-var:INSTANCE > '->' ( > type-var > '->' )*  > type-var:RETURN ')'
op-var         : ( '*' | Operation ) fn-var

% Modularisation
file           : module | library
library        : form

% Implementation
module         : (, -declaration)+ .
declaration    : val | key | family | process | fn | op | behaviour | fault | notation | data | unit | dimension | ratio | when | comment

fault          : 'fault' & >> Fault > '::', Type, values?

ratio          : 'ratio' & >> Ratio > '::', Type, '=', set .

aspects        : (Atom >>)*

% Values
val            : 'val' & >> Constant > '::' > [type >] '=' > expr .
key            : 'key' & >> Key > '::' > type .

data           : 'data' & >> Data > '::', (record | type), format*, enumeration?
record         : '('& , field, (',', field,)* ')'
field          : type >> Field
format         : ':'&, ('#'& -pattern '[]'? | '"' -pattern '"' ),
pattern        : '(' ( (type | literal)+','?,)+ ')'
enumeration    : '=', form

dimension      : 'dimension' & >> -primitive, enumeration?
unit           : 'unit' & >> -primitive
primitive      : Type & > ['[' UnitSymbol ']'] > '::', aspects  [('()'|Type) > values? > (',' > Constant >)*], format*

% Somewhat abstract data types
notation       : 'notation' & >> Notation > '::', type?, [ '=', '{', type, (',', type,) '}' ]:members

behaviour      : 'behaviour' & >> Behaviour (>> TypeVariable)* > '::', '=' > '{', Operation, (',', Operation,)* '}'

% Functions
op             : 'op' & >> Operation > ['[' Operator ']'] > '::', Operation?, signature

fn             : ('fn'|'proc') & >> Function > ['[' Operator ']'] > '::', signature?, implementation, [ where ] 
signature      : -descriptor | '('& > -descriptor > ')'
descriptor     : ( parameter > '->' > )+ type
parameter      : type >> -Identifier:NAME
implementation : '='& (((,[z'.'>] -seq > ':' -case)+ [,[z'.'>]':' -case]) | -case | ,'?'. )
case           : , expr .
where          : 'where' & , -clause > (-clause > )*
clause         : switch | variable | bind | specialisation
switch         : '*' > '='& > expr .
variable       : type >> Identifier > (select | '=' > expr .)
select         : (, '|='& > expr . )+
specialisation : type > -Specialisation > Type .
bind           : Function > -Specialisation > Operation (> type)* .

% Expressions
seq            : expr (, ','?, expr )*
expr           : form ( > form )*
form           : eval | tuple | list | set | comment | term
eval           : '(:=', -seq, ')'
inline         : '~' Function
tuple          : '()' | '(', -seq, ')'
list           : '[]' | '[', -seq, ']'
set            : '{}' | '{', -seq, '}'
comment        : '%' .. '%'
term           : Wildcard | Atom | Key | values | literal | Constant 
               | Operator | Identifier | inline | Type | Fault | Variable | TypeVariable

% Processes
process        : 'process' & >> Process > '::', '=', (list | set)
when           : 'when' & >> state > '::', signature, effects, -transitions, where?
state          : Fault | ('_!'):any-fault | Constant
effects        : (effect .)*
effect         : 9'.' & [>> Constant>':']  >> expr
transitions    : '..', ( (transition .)* | .)
transition     : ['\'& > -seq > '\',] > Constant > ':', expr