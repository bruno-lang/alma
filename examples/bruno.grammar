% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '>'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Self           : '~'
Wild-card      : '_'
Open           : '?'

% Identifiers
Atom           : '`' -{_}+
Key            : -KeyOf -{ Z _ ',' } -{ _ ',' '{' '}' '(' ')' '[' ']'}*
Variable       : '?'{ @ 9 '-' '_' }+
TypeVariable   : Z 9?
Noun           : Z { @ '-' }+ { @  9 '!' }* | '^' 9+
Verb           : z { z 9 '-' }* { z 9 }? {'?' '!'}?

% Operators
OperatorSymbol : { '+' '-' '/' '*' '=' '>' '<' '&' }
Operator       : -OperatorSymbol { OperatorSymbol '!' '?' '|' }**0-2 | { OperatorSymbol '|' }**2-3

% Literals
LiteralSymbol  : -{ _ '?' '#' '"' '=' '>' '<' '&' '|' ')' '}' ']' '.' ',' ';' '*' '\'}
literal        : quoted | unquoted
quoted         : '"""'!, (..):TEXT (, '"""') | '"'! (-{'"'}*):TEXT '"'
unquoted       : ''' $ -LiteralSymbol* | numeric (numeric | -LiteralSymbol)*
numeric        : {'+' '-'}? 9+ ({'.' ','} 9+)*  


% Types
variant        : { Faulty Optional Transient }
indirection    : { TypeOf LazyOf KeyOf }

dimension      : slice-type | channel-type | array-type
slice-type     : '[<' -length-type ! '>]'
channel-type   : {'[' ']'} {'<' '>'}**1..2 ! {'[' ']'}
array-type     : '[' Noun ']' | '['! -length-type ']'
length-type    : span-type | scalar-type
span-type      : scalar-type:MIN '-' scalar-type:MAX
scalar-type    : 9+ | '*' | TypeVariable

subrange       : '{'! subrange-type ('|' subrange-type)* '}' 
subrange-type  : [value-type:MIN] ['..' [value-type:MAX]]
value-type     : literal | scalar-type

type           : shape | -complex-type 
complex-type   : sum-type (, '&', sum-type)*
sum-type       : [,'+' >] full-type (,'+' > full-type)*
full-type      : indirection? -kind dimension* variant?
kind           : Wild-card | ordinal-type | list-type | set-type | fn-type | tuple-type | named-type | length-type | TypeVariable
named-type     : Noun subrange?
ordinal-type   : '#'! -complex-type
list-type      : '['! type ']'
set-type       : '{'! type '}'
fn-type        : '(' [type:INSTANCE >] '->'! ( > type > '->' )* [> type:RETURN] ')'
tuple-type     : '(' ({'\' ';' ',' ' '}:X? > label? ['..' | type] )+ ')'
label          : , -Verb ':' >

shape          : Self | '[]' | '{}' | '()' | '""' | Atom | Key | literal


% Modularisation
file           : module | library
library        : form
module         : (, -declaration)+ ,
declaration    : def | data | when | fn | family | op | concept | fault | ratio | comment
attrs          : (Atom >>)*

fault          : 'fault' ! >> Noun > '::', named-type .


% Data
ratio          : 'ratio' ! >> Noun > '::', literal > '=' > literal .
data           : 'data' ! >> (Key | Noun) > '::', attrs type enumeration? with* init? .
with           : , 'with'! >> ('"'Noun'"'|Noun'[]') > '::', type
enumeration    : , '{'!, constants, '}'
constants      : constant (, '|'!, constant )* 
constant       : name [, ':'! > type] init?
name           : Wild-card | Key | Noun
init           : ,'='! > (Open | expr )


% Functions
fn             : ('fn'|'proc')! >>  Verb > ['`' Operator '`'] > '::', signature?, implementation
signature      : -descriptor | '('! > -descriptor > ')'
descriptor     : ( parameter > '->' > )+ type
parameter      : type >> -Verb:NAME
implementation : '='! , ( case | Open . )
case           : > where | divider | [> {z '?'}'.'] > (expr condition? | condition) > \n case?
divider        : > '-'**4+ -{\n}* \n case
condition      : (> '|' > expr)+
where          : 'where' ! , variable > (variable > )*
variable       : Verb [> ':' > type] > (select | '=' > expr .)
select         : (, '|='! > expr . )+


% Expressions
seq            : expr (, ','?, expr )*
expr           : form ( > form )*
form           : expand | tuple | list | set | comment | implicit | inline | term
expand         : '(:=', -seq, ')'
inline         : '\' Verb
implicit       : '\(' > expr > ')'
tuple          : '()' | '(', -seq, ')'
list           : '[]' | '[', -seq, ']'
set            : '{}' | '{', -seq, '}'
comment        : '%' .. '%'
term           : Wild-card | Atom | Key | literal | Variable | Operator | Verb | Noun | TypeVariable


% Abstract Data Types
op             : 'op' ! >> Verb > ['`' Operator '`'] > '::', Verb?, signature
concept        : 'concept' ! >> Noun (>> TypeVariable)* > '::', '=' > '{', Verb, (',', Verb,)* '}'
family         : 'family' ! >> TypeVariable > attrs '::', type family-as?  family-with?
family-as      : , 'as' as-concept (>',' as-concept)*
as-concept     : > Noun (>> TypeVariable)*
family-with    : , 'with' > Verb (> ',' > Verb)*


% Processes
when           : 'when' ! >> state > '::', signature, effects, -transitions, where?
state          : ('_!'):any-fault | Noun
effects        : (effect .)*
effect         : 9'.' ! [>> Noun>':']  >> expr
transitions    : '..', ( (transition .)* | .)
transition     : > Noun > ':', expr condition?

% Definitions
def            : 'def' ! >> name > '::' > '=', expr .