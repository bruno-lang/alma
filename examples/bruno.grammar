% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '>'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Self           : '~'
Wild-card      : '_'
Open           : '?'

% Identifiers
Atom           : '`' -{_}+
Key            : -KeyOf -{ Z _ ',' } -{ _ ',' '{' '}' '(' ')' '[' ']'}*
Variable       : '?'{ @ 9 '-' '_' }+
TypeVariable   : Z 9?
Noun           : Z { @ '-' }+ { @  9 '!' }* | '^' 9+
Verb           : z { z 9 '-' }* { z 9 }? {'?' '!'}?
name           : Key | Noun

% Operators
OperatorSymbol : { '+' '-' '/' '*' '=' '>' '<' '&' }
Operator       : -OperatorSymbol { OperatorSymbol '!' '?' '|' }**0-2 | { OperatorSymbol '|' }**2-3

% Literals
LiteralSymbol  : -{ _ '?' '#' '"' '=' '>' '<' '&' '|' ')' '}' ']' '.' ',' ';' '*' '\'}
literal        : quoted | unquoted
quoted         : '"""'!, (..):TEXT (, '"""') | '"'! (-{'"'}*):TEXT '"'
unquoted       : ''' $ -LiteralSymbol* | numeric (numeric | -LiteralSymbol)*
numeric        : {'+' '-'}? 9+ ({'.' ','} 9+)*  


% Types
variant        : { Faulty Optional Transient }
indirection    : { TypeOf LazyOf KeyOf }

dimension      : slice-type | channel-type | array-type
slice-type     : '[<' -length-type ! '>]'
channel-type   : {'[' ']'} {'<' '>'}**1..2 ! {'[' ']'}
array-type     : '[' Noun ']' | '['! -length-type ']'
length-type    : span-type | scalar-type
span-type      : scalar-type:MIN '-' scalar-type:MAX
scalar-type    : 9+ | '*' | TypeVariable

subrange       : '{'! subrange-type ('|' subrange-type)* '}' 
subrange-type  : [value-type:MIN] ['..' [value-type:MAX]]
value-type     : literal | scalar-type

type           : shape | -complex-type 
complex-type   : sum-type (, '&', sum-type)*
sum-type       : [,'+' >] full-type (,'+' > full-type)*
full-type      : indirection? -kind dimension* variant?
kind           : Wild-card | ordinal-type | list-type | set-type | fn-type | tuple-type | named-type | length-type | TypeVariable
named-type     : Noun subrange?
ordinal-type   : '#'! -complex-type
list-type      : '['! type ']'
set-type       : '{'! type '}'
fn-type        : '(->)' | '(' type:INSTANCE > '->'! ( > type > '->' )* > type:RETURN ')'
tuple-type     : '()' | '(,)' | '(' field ({'\' ';' ','}:X? > field )* ')'
field          : label? ('..' | type) >
label          : , -Verb ':' >

shape          : Self | '[]' | '{}' | '()' | '""' | Atom | Key | literal

% /////////////////////////////////////////////////////////////////////////////

% Modularisation
file           : module | library
library        : form
module         : (, -declaration)+ ,
declaration    : def | data | when | fn | family | op | concept | fault | ratio | comment
attrs          : (Atom >>)*

fault          : 'fault' ! >> Noun > '::', named-type .


% Data
ratio          : 'ratio' ! >> Noun > '::', literal > '=' > literal .
data           : 'data' ! >> -name > '::', attrs type enumeration? with* init? .
with           : , 'with'! >> ('"'Noun'"'|Noun'[]') > '::', type
enumeration    : , '{'!, constants, '}'
constants      : constant (, '|'!, constant )* 
constant       : '..' | -name [, ':'! > type] init?
init           : ,'='! > (Open | expr )


% Functions
fn             : ('fn'|'proc')! >>  Verb > ['`' Operator '`'] > '::', in-out?, implementation
in-out         : -descriptor | '('! > -descriptor > ')'
descriptor     : ( parameter > '->' > )+ type
parameter      : type >> [-Verb:NAME]
implementation : '='! , ( case | Open . )
case           : > where | hline | [> {z '?'}'.'] > (expr condition? | condition) > \n case?
hline          : > '-'**4+ -{\n}* \n case
condition      : (> '|' > expr)+
where          : 'where' ! , variable > (variable > )*
variable       : Verb [> ':' > type] > (select | '=' > expr .)
select         : (, '|='! > expr . )+


% Expressions
seq            : expr (, ','?, expr )*
expr           : form ( > form )*
form           : expand | tuple | list | set | comment | implicit | inline | term
expand         : '(:='!, -seq, ')'
inline         : '\' Verb
implicit       : '\('! > expr > ')'
tuple          : '()' | '('!, -seq, ')'
list           : '[]' | '['!, -seq, ']'
set            : '{}' | '{'!, -seq, '}'
comment        : '%' .. '%'
term           : Wild-card | Atom | Key | literal | Variable | Operator | Verb | Noun | TypeVariable


% Abstract Data Types
op             : 'op' ! >> Verb > ['`' Operator '`'] > '::', Verb?, in-out
concept        : 'concept' ! >> Noun (>> TypeVariable)* > '::', '=' > '{', Verb, (',', Verb,)* '}'
family         : 'family' ! >> TypeVariable > attrs '::', type family-as?  family-with?
family-as      : , 'as' as-concept (>',' as-concept)*
as-concept     : > Noun (>> TypeVariable)*
family-with    : , 'with' > Verb (> ',' > Verb)*


% Processes
when           : ('when' | 'on') ! >> Noun > '::', in-out, (effect .)*, then, where?
effect         : 9'.' ! [>> Noun>':']  >> expr
then           : '..', ( (transition .)* | .)
transition     : > Noun > ':', expr condition?

% Definitions
def            : 'def' ! >> name > '::' > '=', expr .