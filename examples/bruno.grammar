% Fragments
Verb           : z { z 9 '-' }* { z 9 }?
Noun           : Z { @ '-' }+ { @  9 }*
Identifier     : -Verb {'?' '!'}?

% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '~'
SliceOf        : ':'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Specialisation : '+>'

% Identifiers
Wildcard       : '_'
Field          : -Verb
Constant       : -Noun
Atom           : '`'{ !_ }+
Key            : -KeyOf{ !Z !_ !',' }{ !_ !',' !'{' !'}' !'(' !')' !'[' !']'}*
Variable       : '?'{ @ 9 '-' '_' }+

Operation      : -Identifier
Function       : -Identifier

TypeVariable   : Z 9?
Behaviour      : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Unit           : -Noun
Dimension      : -Noun
Notation       : -Noun
Type           : -Noun
Process        : -Noun
Fault          : -Noun '!'

% Operators
Operator       : -OperatorSymbol { OperatorSymbol '!' '?' }x0-2
OperatorSymbol : { '+' '-' '/' '*' '=' '>' '<' '&' '|' }

% Literals
LiteralSymbol  : { !_ !'?' !'#' !'"' !'=' !'>' !'<' !'&' !'|' !')' !'}' !']' !':' !'.' !',' !';' !'*'}
literal        : conceptual | textual | binary
conceptual     : ''' $ -LiteralSymbol* | numeric (numeric | -LiteralSymbol)*

textual        : '"""', (..):TEXT (, '"""') | '"' (!'"'*):TEXT '"'
binary         : '#'& ('b'& 1+ | 'o'& 7+ | 'x'& #+ | 'd'? 9+ ):NUMBER 
numeric        : ({'+' '-'}?):SIGN (9+ ({'.' ','} 9+)*):DECIMAL  

% Types
variant        : { Faulty Optional Transient }
indirection    : { TypeOf LazyOf KeyOf }

length-type    : 9+ | '*' | Type | TypeVariable
span-type      : length-type:MIN '-' length-type:MAX
dimension-type : '[' SliceOf? [span-type|length-type] ']'

range-type     : '{' [literal:MIN] ':'& [literal:MAX] '}' 
value-set-type : '{'& literal ('|' literal)* '}'

channel-type   : {'[' ']'} {'<' '>'}x1-2 & {'[' ']'}
stream-type    : {'<' '>'}
dimensions     : stream-type? dimension-type* [channel-type* dimension-type?]
type           : shape | op-type | indirection? -base-type dimensions? variant?
base-type      : simple-type | list-type | set-type | tuple-type | fn-type | TypeVariable
simple-type    : Type [range-type | value-set-type]
list-type      : '['& -type ']'
set-type       : '{'& -type '}'
tuple-type     : '(' [ type (('..'|','?' ') type )* ] ')'
fn-type        : '(' type:INSTANCE > '->'& ( > type > '->' )* > type:RETURN ')'
op-type        : Operation fn-type

% Shapes
shape          : '[]' | '{}' | '""' | Atom | Key | conceptual:SHAPE

% Type Families / Variables
family         : 'family' & >> TypeVariable > '::', type-var [, 'as' as-behaviour (>',' as-behaviour)* ] [, 'with' > Operation (> ',' > Operation)*]
as-behaviour   : > Behaviour (>> TypeVariable)*
type-var       : shape | op-var | indirection? -kind-var dimensions? variant?
kind-var       : Wildcard | simple-type | span-type | length-type | list-var | set-var | tuple-var | fn-var | TypeVariable
list-var       : '[' -type-var ']'
set-var        : '{' -type-var '}'
elem-var       : '..' | type-var
tuple-var      : '(,)' | '(' [ -elem-var (> ',' > -elem-var )* ]  ')'
fn-var         : '(->)' | '(' type-var:INSTANCE > '->' ( > type-var > '->' )*  > type-var:RETURN ')'
op-var         : ( '?' | Operation ) fn-var

% Modularisation
file           : module | library
library        : form

% Implementation
module         : (, -declaration)+ .
declaration    : val | key | family | process | fn | op | behaviour | fault | notation | data | unit | dimension | ratio | when | comment

fault          : 'fault' & >> Fault > '::', simple-type .

ratio          : 'ratio' & >> Ratio > '::', Type, '=', set .
natures        : (Atom >>)*

% Constants
val            : 'val' & >> Constant > '::' > [type >] '=' > expr .
key            : 'key' & >> Key > '::' > type .

% Value Types
data           : 'data' & >> Data > '::', (record | type), valence*, enumeration?
record         : '('& , field, (',', field,)* ')'
field          : type >> Field
dimension      : 'dimension' & >> -primitive, enumeration?
unit           : 'unit' & >> -primitive
primitive      : Type & > '::', natures  ['()'|simple-type], valence*
valence        : , ':'& > type
enumeration    : '=', form

% ADTs
notation       : 'notation' & >> Notation > '::', type?, [ '=', '{', type, (',', type,) '}' ]:members
behaviour      : 'behaviour' & >> Behaviour (>> TypeVariable)* > '::', '=' > '{', Operation, (',', Operation,)* '}'

% Functions
op             : 'op' & >> Operation > ['[' Operator ']'] > '::', Operation?, signature

fn             : ('fn'|'proc') & >> Function > ['[' Operator ']'] > '::', signature?, implementation, [ where ] 
signature      : -descriptor | '('& > -descriptor > ')'
descriptor     : ( parameter > '->' > )+ type
parameter      : type >> -Identifier:NAME
implementation : '='& (((,[z'.'>] -seq > ':' -case)+ [,[z'.'>]':' -case]) | -case | ,'?'. )
case           : , expr .
where          : 'where' & , -clause > (-clause > )*
clause         : switch | variable | bind | specialisation
switch         : '?.'& > seq > ':'.
variable       : type >> Identifier > (select | '=' > expr .)
select         : (, '|='& > expr . )+
specialisation : type > -Specialisation > Type .
bind           : Function > -Specialisation > Operation (> type)* .

% Expressions
seq            : expr (, ','?, expr )*
expr           : form ( > form )*
form           : eval | tuple | list | set | comment | term
eval           : '(:=', -seq, ')'
inline         : '~' Function
tuple          : '()' | '(', -seq, ')'
list           : '[]' | '[', -seq, ']'
set            : '{}' | '{', -seq, '}'
comment        : '%' .. '%'
% nota bene (call site literal comments)
nb             : '\' @+ 
term           : Wildcard | Atom | Key | literal-comp | constant-comp
               | Operator | Identifier | inline | Type | Fault | Variable | TypeVariable

literal-comp   : (literal-set | literal-range | constant-range | literal) nb?
literal-set    : '{' > literal > (',' > literal > )* '}'
literal-range  : literal [ > '..' > literal ] | '..' > literal

constant-comp  : constant-range | Constant
constant-range : Constant [ > '..' > Constant ] | '..' > Constant

% Processes
process        : 'process' & >> Process > '::', '=', (list | set)
when           : 'when' & >> state > '::', signature, effects, -transitions, where?
state          : Fault | ('_!'):any-fault | Constant
effects        : (effect .)*
effect         : 9'.' & [>> Constant>':']  >> expr
transitions    : '..', ( (transition .)* | .)
transition     : ['\'& > -seq > '\',] > Constant > ':', expr