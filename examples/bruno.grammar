% Fragments
Verb           : z { z 9 '-' }* { z 9 }?
Noun           : Z { @ '-' }+ { @  9 }*
Identifier     : -Verb {'?' '!'}?

% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '>'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Specialisation : '+>'
Self           : '~'

% Identifiers
Wildcard       : '_'
Field          : -Verb
Constant       : -NumberConstant | -Noun
NumberConstant : '#' 9+
Atom           : '`'{ !_ }+
Key            : -KeyOf{ !Z !_ !',' }{ !_ !',' !'{' !'}' !'(' !')' !'[' !']'}*
Variable       : '?'{ @ 9 '-' '_' }+

Operation      : -Identifier
Function       : -Identifier

TypeVariable   : Z 9?
Concept        : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Notation       : -Noun
Type           : -Noun
Process        : -Noun
Fault          : -Noun '!'

% Operators
Operator       : -OperatorSymbol { OperatorSymbol '!' '?' }x0-2
OperatorSymbol : { '+' '-' '/' '*' '=' '>' '<' '&' '|' }

% Literals
LiteralSymbol  : { !_ !'?' !'#' !'"' !'=' !'>' !'<' !'&' !'|' !')' !'}' !']' !'.' !',' !';' !'*' !'\'}
literal        : conceptual | textual | binary
conceptual     : ''' $ -LiteralSymbol* | numeric (numeric | -LiteralSymbol)*

textual        : '"""', (..):TEXT (, '"""') | '"' (!'"'*):TEXT '"'
binary         : '#'& ('b'& 1+ | 'o'& 7+ | 'x'& #+ | 'd'& 9+ ):NUMBER 
numeric        : {'+' '-'}? 9+ ({'.' ','} 9+)*  

% Types
variant        : { Faulty Optional Transient }
indirection    : { TypeOf LazyOf KeyOf }

length-type    : 9+ | '*' | TypeVariable
span-type      : length-type:MIN '-' length-type:MAX
dimension-type : slice-type | '['  [ -quantity-type ]  ']'
slice-type     : '[<' [ -quantity-type ] '>]'
quantity-type  : span-type | length-type | Type

value-type     : literal | length-type
range-type     : '{' [value-type:MIN] '..'& [value-type:MAX] '}' 
value-set-type : '{'& value-type ('|' value-type)* '}'

channel-type   : {'[' ']'} {'<' '>'}x1-2 & {'[' ']'}
stream-type    : {'<' '>'}
dimensions     : stream-type? dimension-type* [channel-type* dimension-type?]
type           : Self | shape | op-type | indirection? -base-type dimensions? variant?
base-type      : simple-type | list-type | set-type | tuple-type | fn-type | TypeVariable
simple-type    : Type [range-type | value-set-type]
list-type      : '['& -type ']'
set-type       : '{'& -type '}'
tuple-type     : '(' [ type ((('\'):AND|','?' ') type )* ] ')'
fn-type        : '(' type:INSTANCE > '->'& ( > type > '->' )* > type:RETURN ')'
op-type        : Operation fn-type

% Shapes
shape          : '[]' | '{}' | '""' | Atom | Key | NumberConstant | literal:SHAPE

% Type Families / Variables
family         : 'family' & >> TypeVariable > '::', type-var [, 'as' as-concept (>',' as-concept)* ] [, 'with' > Operation (> ',' > Operation)*]
as-concept     : > Concept (>> TypeVariable)*
type-var       : Self | shape | op-var | indirection? -kind-var dimensions? variant?
kind-var       : Wildcard | simple-type | span-type | length-type | list-var | set-var | tuple-var | fn-var | TypeVariable
list-var       : '[' -type-var ']'
set-var        : '{' -type-var '}'
elem-var       : '..' | type-var
tuple-var      : '(,)' | '(' [ -elem-var (> ',' > -elem-var )* ]  ')'
fn-var         : '(->)' | '(' type-var:INSTANCE > '->' ( > type-var > '->' )*  > type-var:RETURN ')'
op-var         : ( '?' | Operation ) fn-var

% Modularisation
file           : module | library
library        : form

% Implementation
module         : (, -declaration)+ .
declaration    : family | process | fn | op | concept | fault | notation | data | ratio | when | comment

fault          : 'fault' & >> Fault > '::', simple-type .

ratio          : 'ratio' & >> Ratio > '::', literal > '=' > literal .

% Value Types & Constants
data           : 'data' & >> (Key | Data) > '::', attrs (type|record) -valences [,'='& > expr] .
attrs          : (Atom >>)*
record         : '('& , field, (',', field,)* ')'
field          : type >> Field
valences       : (, valence )*
valence        : ':'& > type | '['&, constants, ']' | '{'&, constants, '}'
constants      : constant (, '|'&, constant )* 
constant       : (Wildcard | Fault | Key | Constant), valence? ['='& > expr]

% ADTs
notation       : 'notation' & >> Notation > '::', type?, [ '=', '{', type, (',', type,) '}' ]:members
concept        : 'concept' & >> Concept (>> TypeVariable)* > '::', '=' > '{', Operation, (',', Operation,)* '}'

% Functions
op             : 'op' & >> Operation > ['[' Operator ']'] > '::', Operation?, signature

fn             : ('fn'|'proc') & >> Function > ['[' Operator ']'] > '::', signature?, implementation, [ where ] 
signature      : -descriptor | '('& > -descriptor > ')'
descriptor     : ( parameter > '->' > )+ type
parameter      : type >> -Identifier:NAME
implementation : '='& (((,[z'.'>] -seq > ':' -case)+ [,[z'.'>]':' -case]) | -case | ,'?'. )
case           : , expr .
where          : 'where' & , -clause > (-clause > )*
clause         : switch | variable | bind | specialisation
switch         : '?.'& > seq > ':'.
variable       : type >> Identifier > (select | '=' > expr .)
select         : (, '|='& > expr . )+
specialisation : type > -Specialisation > Type .
bind           : Function > -Specialisation > Operation (> type)* .
% TODO: specialisation for a variable that is bound for a concept stating the used functions or the mapping!

% Expressions
seq            : expr (, ','?, expr )*
expr           : form ( > form )*
form           : eval | tuple | list | set | comment | term
eval           : '(:=', -seq, ')'
inline         : '\' Function
tuple          : '()' | '(', -seq, ')'
list           : '[]' | '[', -seq, ']'
set            : '{}' | '{', -seq, '}'
comment        : '%' .. '%'
term           : Wildcard | Atom | Key | literal
               | Operator | Identifier | inline | Type | Fault | Variable | TypeVariable

% Processes
process        : 'process' & >> Process > '::', valences
when           : 'when' & >> state > '::', signature, effects, -transitions, where?
state          : Fault | ('_!'):any-fault | Constant
effects        : (effect .)*
effect         : 9'.' & [>> Constant>':']  >> expr
transitions    : '..', ( (transition .)* | .)
transition     : ['\'& > -seq > '\',] > Constant > ':', expr