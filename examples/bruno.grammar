% Fragments
Verb           : z { z 9 '-' }* { z 9 }?
Noun           : Z { @ '-' }+ { @  9 }*
Identifier     : -Verb {'?' '!'}?

% Type Variant Symbols
TypeOf         : '$'
LazyOf         : '>'
KeyOf          : '@'
Optional       : '?'
Faulty         : '!'
Transient      : '*'
Specialisation : '+>'
Self           : '~'
Then           : '.{'

% Identifiers
Wildcard       : '_'
Field          : -Verb
Constant       : -NumberConstant | -Noun
NumberConstant : '#' 9+
Atom           : '`'{ !_ }+
Key            : -KeyOf{ !Z !_ !',' }{ !_ !',' !'{' !'}' !'(' !')' !'[' !']'}*
Variable       : '?'{ @ 9 '-' '_' }+

Operation      : -Identifier
Function       : -Identifier

TypeVariable   : Z 9?
Concept        : -Noun
Data           : -Noun
System         : -Noun
Ratio          : -Noun
Notation       : -Noun
Type           : -Noun
Process        : -Noun
Fault          : -Noun '!'

% Operators
Operator       : { OperatorSymbol ':'} { OperatorSymbol '!' '?' }x0-2
OperatorSymbol : { '+' '-' '/' '*' '=' '>' '<' '&' '|' }

% Literals
LiteralSymbol  : { !_ !'?' !'#' !'"' !'=' !'>' !'<' !'&' !'|' !')' !'}' !']' !'.' !',' !';' !'*' !'\'}
literal        : conceptual | textual | binary
conceptual     : ''' $ -LiteralSymbol* | numeric (numeric | -LiteralSymbol)*

textual        : '"""', (..):TEXT (, '"""') | '"' (!'"'*):TEXT '"'
binary         : '#'& ('b'& 1+ | 'o'& 7+ | 'x'& #+ | 'd'& 9+ ):NUMBER 
numeric        : {'+' '-'}? 9+ ({'.' ','} 9+)*  

% Types
variant        : { Faulty Optional Transient }
indirection    : { TypeOf LazyOf KeyOf }

scalar-type    : 9+ | '*' | TypeVariable
span-type      : scalar-type:MIN '-' scalar-type:MAX
length-type    : span-type | scalar-type | Type
ordinal-type   : '[<' [ -length-type ] '>]' | '['  [ -length-type ]  ']'

value-type     : literal | scalar-type
subrange-type  : '{' [value-type:MIN] '..'& [value-type:MAX] '}' 
subset-type    : '{'& value-type ('|' value-type)* '}'

channel-type   : {'[' ']'} {'<' '>'}x1-2 & {'[' ']'}
stream-type    : {'<' '>'}
dimensions     : stream-type? ordinal-type* [channel-type* ordinal-type?]
type           : shape | indirection? -base-type dimensions? variant? sum-type?
base-type      : sum-type | simple-type | list-type | set-type | tuple-type | fn-type | TypeVariable
simple-type    : Type [subrange-type | subset-type]
sum-type       : , '+' > type
list-type      : '['& type ']'
set-type       : '{'& type '}'
tuple-type     : '(' [ label? type ({'\' ',' ' '}:AND > label? type )* ] ')'
label          : , -Verb ':' >
fn-type        : '(' type:INSTANCE > '->'& ( > type > '->' )* > type:RETURN ')'

% Shapes
shape          : Self | '[]' | '{}' | '""' | Atom | Key | NumberConstant | literal

% Type Families / Variables
family         : 'family' & >> TypeVariable > '::', type-var [, 'as' as-concept (>',' as-concept)* ] [, 'with' > Operation (> ',' > Operation)*]
as-concept     : > Concept (>> TypeVariable)*
type-var       : shape | op-var | indirection? -kind-var dimensions? variant?
kind-var       : Wildcard | simple-type | span-type | scalar-type | list-var | set-var | tuple-var | fn-var | TypeVariable
list-var       : '[' -type-var ']'
set-var        : '{' -type-var '}'
elem-var       : '..' | type-var
tuple-var      : '(,)' | '(' [ -elem-var (> ',' > -elem-var )* ]  ')'
fn-var         : '(->)' | '(' type-var:INSTANCE > '->' ( > type-var > '->' )*  > type-var:RETURN ')'
op-var         : ( '?' | Operation ) fn-var

% Modularisation
file           : module | library
library        : form

% Implementation
module         : (, -declaration)+
declaration    : def | data | when | process | fn | family | op | concept | fault | ratio | comment

fault          : 'fault' & >> Fault > '::', simple-type .

ratio          : 'ratio' & >> Ratio > '::', literal > '=' > literal .

% Value Types & Constants (incl. enumerations and algebraic data types)
data           : 'data' & >> (Key | Data) > '::', attrs types ((, with)+ | (, enumeration)* ) init .
attrs          : (Atom >>)*
with           : 'with'& >> ('"'Data'"'|Data'[]') > '::', types 
types          : type (,'&', type)*
enumeration    : '['&, constants, ']' | '{'&, constants, '}'
constants      : constant (, '|'&, constant )* 
constant       : name [, ':'& types] init
name           : Wildcard | Fault | Key | Constant
init           : [,'='& > expr]

% Abstract Data Types
concept        : 'concept' & >> Concept (>> TypeVariable)* > '::', '=' > '{', Operation, (',', Operation,)* '}'

% Functions
op             : 'op' & >> Operation > ['`' Operator '`'] > '::', Operation?, signature

fn             : ('fn'|'proc')& >>  Function > ['`' Operator '`'] > '::', signature?, implementation, [ where ] 
signature      : -descriptor | '('& > -descriptor > ')'
descriptor     : ( parameter > '->' > )+ type
parameter      : type >> -Identifier:NAME
implementation : '='& (((,[z'.'>] -seq > -Then case)+ [,[z'.'>] -Then case]) | -case | ,'?'. )
case           : , expr .
where          : 'where' & , -clause > (-clause > )*
clause         : switch | variable | bind | specialisation
switch         : '?.'& > seq > -Then.
variable       : Identifier[> ':' > type] > (select | '=' > expr .)
select         : (, '|='& > expr . )+
specialisation : type > -Specialisation > Type .
bind           : Function > -Specialisation > Operation (> type)* .
% TODO: specialisation for a variable that is bound for a concept stating the used functions or the mapping!

% Expressions
seq            : expr (, ','?, expr )*
expr           : form ( > form )*
form           : eval | tuple | list | set | comment | term
eval           : '(:=', -seq, ')'
inline         : '\' Function
tuple          : '()' | '(', -seq, ')'
list           : '[]' | '[', -seq, ']'
set            : '{}' | '{', -seq, '}'
comment        : '%' .. '%'
term           : Wildcard | Atom | Key | literal
               | Operator | Identifier | inline | Type | Fault | Variable | TypeVariable

% Processes
process        : 'process' & >> Process > '::' (, enumeration)+ .
when           : 'when' & >> state > '::', signature, effects, -transitions, where?
state          : Fault | ('_!'):any-fault | Constant
effects        : (effect .)*
effect         : 9'.' & [>> Constant>':']  >> expr
transitions    : '..', ( (transition .)* | .)
transition     : ['\'& > -seq > '\',] > Constant > ':', expr

% Definitions
def            : 'def' & >> name > '::' > '=', expr .